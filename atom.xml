<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>涂祎豪の博客</title>
  
  <subtitle>记录生活与学习的点点滴滴</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-09-27T08:08:12.000Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>涂祎豪</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>阿里巴巴Java开发手册学习</title>
    <link href="http://example.com/2020/11/08/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2020/11/08/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-11-08T02:05:46.681Z</published>
    <updated>2020-09-27T08:08:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="阿里巴巴Java开发手册学习"><a href="#阿里巴巴Java开发手册学习" class="headerlink" title="阿里巴巴Java开发手册学习"></a>阿里巴巴Java开发手册学习</h2><blockquote><p>作者：涂祎豪</p></blockquote><h3 id="第一章-编程规约"><a href="#第一章-编程规约" class="headerlink" title="第一章    编程规约"></a>第一章    编程规约</h3><h4 id="1-1-命名风格"><a href="#1-1-命名风格" class="headerlink" title="1.1 命名风格"></a>1.1 命名风格</h4><ol><li>【强制】代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">反例：_name / $name / name_ </span><br></pre></td></tr></table></figure><ol start="2"><li><p>【强制】代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。</p><p> <em>说明：即使是纯拼音命名方式也要避免采用。</em></p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正例：alibaba / taobao / youku / hangzhou 等国际通用名称，可视同英文。</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">反例：DaZhepromotion [打折] / getPingFenByName() [评分] / <span class="keyword">int</span> 某变量 = <span class="number">3</span></span><br></pre></td></tr></table></figure></li><li><p>【强制】类名使用UpperCamelCase风格，但Do / Bo / DTO / VO / AO / PO 等情形例外。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正例：MarcoPolo / UserDo / XmlService / TcpUdpDeal / TaPromotion / QrCode</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">反例：macroPolo / Userdo / XMLService / TCPUDPDeal / TAPromotion / QRCode</span><br></pre></td></tr></table></figure></li><li><p>【强制】方法名、参数名、成员变量、局部变量都统一使用lowerCamelCase风格，必须遵从驼峰形式。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正例：localValue / getHttpMessage() / inputUserId</span><br></pre></td></tr></table></figure></li><li><p>【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正例：MAX_STOCK_COUNT / CACHE_EXPIRED_TIME</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">反例：MAX_COUNT / EXPIRED_TIME</span><br></pre></td></tr></table></figure></li><li><p>【强制】 抽象类名使用Abstract或Base开头；异常类名使用Exception结尾；测试类名以它要测试的类名开始，以Test结尾。</p></li><li><p>【强制】类型中括号之间无空格连接定义数组。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正例：定义整形数组<span class="keyword">int</span>[] arrayDemo;</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">反例：在main参数中，使用String args[]来定义。</span><br></pre></td></tr></table></figure></li><li><p>【强制】类型与中括号之间无空格相连定义数组。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正例：</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">反例：</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;阿里巴巴Java开发手册学习&quot;&gt;&lt;a href=&quot;#阿里巴巴Java开发手册学习&quot; class=&quot;headerlink&quot; title=&quot;阿里巴巴Java开发手册学习&quot;&gt;&lt;/a&gt;阿里巴巴Java开发手册学习&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;作者：涂祎豪&lt;/p</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>继承</title>
    <link href="http://example.com/2020/11/08/%E7%BB%A7%E6%89%BF/"/>
    <id>http://example.com/2020/11/08/%E7%BB%A7%E6%89%BF/</id>
    <published>2020-11-08T02:05:46.680Z</published>
    <updated>2020-10-09T12:54:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><blockquote><p>作者：涂祎豪</p></blockquote><ul><li><p>继承概述：把多个类中相同的内容给提取出来定义到一个类中</p></li><li><p>如何实现继承？</p><p>  ​    Java提供关键字：extends</p></li><li><p>格式</p><p>  ​    class    子类名    extends 父类名 {}</p></li></ul><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul><li>提高了代码的复用性</li><li>提高了代码的可维护性</li><li>让类与类之间产生了关系，是多态的前提（同时也是继承的弊端，类的耦合性增强了）</li></ul><h3 id="Java中继承的特点"><a href="#Java中继承的特点" class="headerlink" title="Java中继承的特点"></a>Java中继承的特点</h3><ul><li><p>Java只支持单继承，不支持多继承</p><p>  ​    有些语言（C++）支持多继承，格式：extends  类1,类2, .  .  .</p></li><li><p>Java支持多层继承（继承体系）</p></li></ul><h3 id="Java中继承的注意事项"><a href="#Java中继承的注意事项" class="headerlink" title="Java中继承的注意事项"></a>Java中继承的注意事项</h3><ul><li><p>子类只能继承父类所有非私有的成员（成员方法和成员变量）</p><ul><li>其实这也体现了继承的另一个弊端：打破了封装性</li></ul></li><li><p>子类不能继承父类的构造方法，但是可以通过super关键字去访问父类构造方法</p></li><li><p>不要为了部分功能而去继承 </p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//我们发现B类中出现了和A类一样的show2()方法，所以，我们就用继承类体现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show3</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">其实这样不好，因为这样你不但有了show2()，还多了show1()。</span></span><br><span class="line"><span class="comment">有可能show1()不是你想要的。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><p>那么我们什么时候考虑使用继承？</p><p>​    继承其实体现的是一种关系：”is  a”。</p><p>​    如：</p><p>​        Person</p><p>​                Student</p><p>​                Teacher</p><p>采用假设法：</p><p>​        如果有两个类A，B。只有他们复合A是B的一种，或者B是A的一种，就可以考虑使用</p><h3 id="继承中构造方法的关系"><a href="#继承中构造方法的关系" class="headerlink" title="继承中构造方法的关系"></a>继承中构造方法的关系</h3><ul><li><p>子类中所有的构造方法默认都会访问父类中空参数的构造方法</p></li><li><p>为什么？</p><ul><li>因为子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化。</li></ul></li><li><p><em>每一个构造方法的第一条语句默认都是：super()</em></p></li></ul><h3 id="类的组成部分各自关系"><a href="#类的组成部分各自关系" class="headerlink" title="类的组成部分各自关系"></a>类的组成部分各自关系</h3><ul><li><p>子类中的成员变量和父类中的成员变量名称不一样（太简单）</p></li><li><p>子类中的成员变量和父类中的成员变量名称一样，这时会怎样</p><p>  在子类方法中访问一个变量的查找顺序</p><ul><li>在子类方法的局部范围找，有就使用</li><li>在子类的成员范围找，有就使用</li><li>在父类的成员范围找，有就使用</li><li>如果还找不到，就报错。</li></ul></li></ul><h3 id="如果父类没有无参构造方法，那么子类的构造方法会出现什么现象？如何解决？"><a href="#如果父类没有无参构造方法，那么子类的构造方法会出现什么现象？如何解决？" class="headerlink" title="如果父类没有无参构造方法，那么子类的构造方法会出现什么现象？如何解决？"></a>如果父类没有无参构造方法，那么子类的构造方法会出现什么现象？如何解决？</h3><p>报错。</p><ul><li>方法一：在父类中加一个无参构造方法</li><li>方法二：通过使用super关键字区显示的调用其他带参构造方法</li><li>方法三：子类通过this去调用本类的其他构造方法<ul><li>注意：子类中一定要有一个去访问了父类的构造方法，否则父类数据就没有初始化。</li></ul></li></ul><p><strong>注意事项：</strong></p><p>​    this (  .  .  .  ) 或者super (  .  .  .  )必须出现在第一条语句上。</p><p>​    如果不是放在第一条语句上，就可能对父类的数据进行了多次初始化，所以必须放在第一条语句</p><h3 id="继承中的面试题"><a href="#继承中的面试题" class="headerlink" title="继承中的面试题"></a>继承中的面试题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    看程序写结果</span></span><br><span class="line"><span class="comment">        A:成员变量  就近原则</span></span><br><span class="line"><span class="comment">        B:this和super的问题</span></span><br><span class="line"><span class="comment">            this访问本类的成员</span></span><br><span class="line"><span class="comment">            super访问父类的成员</span></span><br><span class="line"><span class="comment">        C:子类构造方法执行前都默认执行父类的无参构造方法</span></span><br><span class="line"><span class="comment">        D:一个类的初始化过程</span></span><br><span class="line"><span class="comment">            成员变量进行初始化</span></span><br><span class="line"><span class="comment">                默认初始化</span></span><br><span class="line"><span class="comment">                显示初始化</span></span><br><span class="line"><span class="comment">                构造方法初始化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fu</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fu</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;fu&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> num = <span class="number">20</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Zi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;zi&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">30</span>;</span><br><span class="line">        System.out.println(num);</span><br><span class="line">        System.out.println(<span class="keyword">this</span>.num);</span><br><span class="line">        System.out.println(<span class="keyword">super</span>.num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtendsDemo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Zi z = <span class="keyword">new</span> Zi();</span><br><span class="line">        z.show();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">fu</span></span><br><span class="line"><span class="comment">zi</span></span><br><span class="line"><span class="comment">30</span></span><br><span class="line"><span class="comment">20</span></span><br><span class="line"><span class="comment">10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="继承中成员方法的关系"><a href="#继承中成员方法的关系" class="headerlink" title="继承中成员方法的关系"></a>继承中成员方法的关系</h3><ul><li><p>子类中的方法和父类中的方法声明不一样，太简单</p></li><li><p>子类中的方法和父类中的不一样</p><p>  通过子类调用方法</p><ul><li>先找子类中，看有没有这个方法，有就使用</li><li>再看父类中，有没有这个方法，有就使用</li><li>如果没有就报错</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; title=&quot;继承&quot;&gt;&lt;/a&gt;继承&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;作者：涂祎豪&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;继承概述：把多个类中相同的内容给提取出来</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>有符号的数据表示法</title>
    <link href="http://example.com/2020/11/08/%E6%9C%89%E7%AC%A6%E5%8F%B7%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%B3%95/"/>
    <id>http://example.com/2020/11/08/%E6%9C%89%E7%AC%A6%E5%8F%B7%E7%9A%84%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%A4%BA%E6%B3%95/</id>
    <published>2020-11-08T02:05:46.678Z</published>
    <updated>2020-09-26T18:06:16.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="有符号的数据表示法（原码，反码，补码）"><a href="#有符号的数据表示法（原码，反码，补码）" class="headerlink" title="有符号的数据表示法（原码，反码，补码）"></a>有符号的数据表示法（原码，反码，补码）</h3><blockquote><p>作者：涂祎豪</p></blockquote><p>在计算机内，有符号数有三种表示法：原码、反码和补码。所有数据的运算都是采用补码进行的。</p><ul><li><p>原码</p><p>  就是二进制定点表示法，即最高位为符号位，“0”表示正，“1”一表示负，其余位表示数值的大小</p></li><li><p>反码</p><p>  正数的反码与原码相同；负数的反码一对其原码逐位取反，但符号位除外</p></li><li><p>补码</p><p>  正数的补码与其原码相同；负数的补码是在其反码的末位加1</p></li></ul><p>用原码，反码，补码来分别表示 +7 和 -7。</p><p>首先我们得到7的二进制：111</p><p>原码： </p><p>正数的原码最高位是0。</p><p>负数的原码最高位是1。</p><p>其他是数值位。</p><table><thead><tr><th></th><th>符号位</th><th>数值位</th></tr></thead><tbody><tr><td>+7</td><td>0</td><td>0000111</td></tr><tr><td>-7</td><td>1</td><td>0000111</td></tr></tbody></table><p>反码：</p><p>正数的反码与原码相同。</p><p>负数的反码与原码是符位不变，数值位取反。</p><table><thead><tr><th></th><th>符号位</th><th>数值位</th></tr></thead><tbody><tr><td>+7</td><td>0</td><td>0000111</td></tr><tr><td>-7</td><td>1</td><td>1111000</td></tr></tbody></table><p> 补码：</p><p>正数的补码与原码相同。</p><p>负数的补码是在反码的基础上加1。</p><table><thead><tr><th></th><th>符号位</th><th>数值位</th></tr></thead><tbody><tr><td>+7</td><td>0</td><td>0000111</td></tr><tr><td>-7</td><td>1</td><td>1111001</td></tr></tbody></table><p>练习：</p><p>A:  已知某数X的原码位10110100B，试求X的补码和反码</p><table><thead><tr><th></th><th>符号位</th><th>数值位</th></tr></thead><tbody><tr><td>原码</td><td>1</td><td>0110100</td></tr><tr><td>反码</td><td>1</td><td>1001011</td></tr><tr><td>补码</td><td>1</td><td>1001100</td></tr></tbody></table><p>B:  已知某数X的补码11101110B，试求其原码</p><table><thead><tr><th></th><th>符号位</th><th>数值位</th></tr></thead><tbody><tr><td>补码</td><td>1</td><td>1101110</td></tr><tr><td>反码</td><td>1</td><td>1101101</td></tr><tr><td>原码</td><td>1</td><td>0010010</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;有符号的数据表示法（原码，反码，补码）&quot;&gt;&lt;a href=&quot;#有符号的数据表示法（原码，反码，补码）&quot; class=&quot;headerlink&quot; title=&quot;有符号的数据表示法（原码，反码，补码）&quot;&gt;&lt;/a&gt;有符号的数据表示法（原码，反码，补码）&lt;/h3&gt;&lt;bloc</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2020/11/08/%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99/"/>
    <id>http://example.com/2020/11/08/%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99/</id>
    <published>2020-11-08T02:05:46.677Z</published>
    <updated>2020-10-09T13:26:12.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h2><ul><li><p>方法重写：子类中出现了父类中方法声明一模一样的方法。</p><p>  <strong>使用特点：</strong></p><ul><li>如果方法名不同，就调用对应的方法</li><li>如果方法名相同，最终使用的是子类自己的</li></ul></li><li><p>方法重载：本类中出现的方法名一样，参数列表不同的方法。与返回值无关。</p></li><li><p>子类对象调用方法的时候：</p><p>  先找子类本身，再找父类</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;方法重写&quot;&gt;&lt;a href=&quot;#方法重写&quot; class=&quot;headerlink&quot; title=&quot;方法重写&quot;&gt;&lt;/a&gt;方法重写&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;方法重写：子类中出现了父类中方法声明一模一样的方法。&lt;/p&gt;
&lt;p&gt;  &lt;strong&gt;使用特点：&lt;/st</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数组</title>
    <link href="http://example.com/2020/11/08/%E6%95%B0%E7%BB%84/"/>
    <id>http://example.com/2020/11/08/%E6%95%B0%E7%BB%84/</id>
    <published>2020-11-08T02:05:46.676Z</published>
    <updated>2020-10-04T14:08:18.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><blockquote><p>作者：涂祎豪</p></blockquote><h3 id="数组概念"><a href="#数组概念" class="headerlink" title="数组概念"></a>数组概念</h3><ul><li> 数组是存储同一种数据类型多个元素的集合。也可以看成是一个容器。</li><li>数组既可以存储基本数据类型，也可以存储引用数据类型。</li></ul><h3 id="数组的定义格式"><a href="#数组的定义格式" class="headerlink" title="数组的定义格式"></a>数组的定义格式</h3><ul><li>格式1：数据类型[] 数组名;</li><li>格式2：数据类型 数组名[];</li><li>注意：这两种定义做完了，数组中是没有元素值的。如何对数组的元素进行初始化呢？ </li></ul><h3 id="数组初始化概述"><a href="#数组初始化概述" class="headerlink" title="数组初始化概述"></a>数组初始化概述</h3><ul><li>Java中的数组必须先初始化，然后才能使用。</li><li>所谓初始化：就是为数组中的数组元素分配内存空间，并为每个数组元素赋值。</li></ul><h3 id="数组的初始化方式"><a href="#数组的初始化方式" class="headerlink" title="数组的初始化方式"></a>数组的初始化方式</h3><p>何谓初始化？就是为数组开辟内存空间，并为每个数组元素赋予值</p><ul><li>动态初始化：初始化时只指定数组长度，由系统为数组分配初始化值。</li><li>静态初始化：初始化时指定每个数组元素的初始值，由系统决定数组长度。</li></ul><h3 id="数组的初始化"><a href="#数组的初始化" class="headerlink" title="数组的初始化"></a>数组的初始化</h3><ul><li>动态初始化：<ul><li>格式：数据类型[] 数组名 = new 数据类型[数组长度];</li><li>数组长度其实就是数组中元素的个数。</li><li>举例<ul><li>int[] arr = new int[3];</li><li>解释：定义一个int类型的数组，之歌数组中可以存放3个int类型的值。</li></ul></li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        左边：</span></span><br><span class="line"><span class="comment">        int:说明数组中的元素的数据类型是int类型</span></span><br><span class="line"><span class="comment">        []:说明这是一个数组</span></span><br><span class="line"><span class="comment">        arr: 是数组的名称</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        右边：</span></span><br><span class="line"><span class="comment">        new:为数组分配内存空间</span></span><br><span class="line"><span class="comment">        int:说明数组中的元素的数据类型都是int类型</span></span><br><span class="line"><span class="comment">        []:说明这是一个数组</span></span><br><span class="line"><span class="comment">        3:数组长度，其实也就是数组元素的个数</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"><span class="comment">//输出数组名</span></span><br><span class="line">System.out.println(arr); <span class="comment">//[I@880ec60 地址值</span></span><br><span class="line"><span class="comment">//输出数组中的元素</span></span><br><span class="line">System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">System.out.println(arr[<span class="number">1</span>]);</span><br><span class="line">System.out.println(arr[<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java中的内存分配"><a href="#Java中的内存分配" class="headerlink" title="Java中的内存分配"></a>Java中的内存分配</h3><ul><li>Java程序运行时，需要在内存中的分配空间。为了提高运算效率，就对空间进行了不同区域的划分，因为每一片区域都有特定的处理数据方式和内存管理方式。<ul><li>栈：存储局部变量</li><li>堆：存储new出来的东西</li><li>方法区</li><li>本地方法区（和系统相关）</li><li>寄存器（给CPU使用）</li></ul></li></ul><p>局部变量：在方法定义中或者方法申明上的变量称为局部变量。</p><p>堆内存的特点：</p><p>A: 每一个new出来的东西都有地址值</p><p>B: 每一个变量都有默认值</p><p>​            byte，short，int，long  为0</p><p>​            float，double 为0.0</p><p>​            char 为’\u0000’</p><p>​            boolean 为 false</p><p>​            引用类型 为 null</p><p>C: 使用完毕就变成了垃圾，但是并没有立即回收。会在垃圾回收器空闲的时候回收</p><p><img src= "/img/loading.gif" data-lazy-src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/20200926110035.png" alt="image-20200926110035202"></p><h3 id="数组常见操作"><a href="#数组常见操作" class="headerlink" title="数组常见操作"></a>数组常见操作</h3><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><h4 id="求最大（小）值"><a href="#求最大（小）值" class="headerlink" title="求最大（小）值"></a>求最大（小）值</h4><p>分析：</p><p>​    A：定义一个数组，并对数组的元素进行静态初始化</p><p>​    B：从数组中任意一个元素作为参照物（一般取第一个），默认它就是最大值</p><p>​    C：然后遍历其他的元素，依次获取和参照物进行比较，如果大就留下来，如果小就离开</p><p>​    D：最后参照物里保存的就是最大值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得最大</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMax</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> max = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; max) &#123;</span><br><span class="line">                max = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获得最小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; min) &#123;</span><br><span class="line">                min = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="数组逆序"><a href="#数组逆序" class="headerlink" title="数组逆序"></a>数组逆序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分析：</span></span><br><span class="line"><span class="comment">A：定义一个数组，并进行静态初始化</span></span><br><span class="line"><span class="comment">B：思路</span></span><br><span class="line"><span class="comment">把0索引和arr.length-1的数据交换</span></span><br><span class="line"><span class="comment">把1索引和arr.length-2的数据交换</span></span><br><span class="line"><span class="comment">。。。</span></span><br><span class="line"><span class="comment">只要做到arr.length/2的时候即可</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个数组，并进行静态初始化</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">12</span>,<span class="number">98</span>,<span class="number">50</span>,<span class="number">34</span>,<span class="number">76</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//逆序前</span></span><br><span class="line">        System.out.println(<span class="string">&quot;逆序前&quot;</span>);</span><br><span class="line">        printArray(arr);</span><br><span class="line">        <span class="comment">//逆序后</span></span><br><span class="line">        System.out.println(<span class="string">&quot;逆序后&quot;</span>);</span><br><span class="line">        reverse(arr);</span><br><span class="line">        printArray(arr);</span><br><span class="line">        <span class="comment">//再次逆序后</span></span><br><span class="line">        System.out.println(<span class="string">&quot;再次逆序后&quot;</span>);</span><br><span class="line">        reverse2(arr);</span><br><span class="line">        printArray(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 需求：数组逆序</span></span><br><span class="line"><span class="comment">    * 两个明确：</span></span><br><span class="line"><span class="comment">    *   返回值类型：void</span></span><br><span class="line"><span class="comment">    *   参数列表：int[] arr</span></span><br><span class="line"><span class="comment">    * */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法一</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; arr.length/<span class="number">2</span>; x++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[x];</span><br><span class="line">            arr[x] = arr[arr.length-<span class="number">1</span>-x];</span><br><span class="line">            arr[arr.length-<span class="number">1</span>-x] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法二</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reverse2</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> start = <span class="number">0</span>, end = arr.length-<span class="number">1</span>; start &lt;= end; start++,end--)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = arr[start];</span><br><span class="line">            arr[start] = arr[end];</span><br><span class="line">            arr[end] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</span><br><span class="line">        System.out.print(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; arr.length; x++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == arr.length-<span class="number">1</span>)&#123; <span class="comment">//这是最后一个元素</span></span><br><span class="line">                System.out.println(arr[x] + <span class="string">&quot;]&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.print(arr[x] + <span class="string">&quot;, &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组查表法（根据键盘录入索引，查找对应星期）"><a href="#数组查表法（根据键盘录入索引，查找对应星期）" class="headerlink" title="数组查表法（根据键盘录入索引，查找对应星期）"></a>数组查表法（根据键盘录入索引，查找对应星期）</h4><p>意思是：String[] strArray = {“星期一”,”星期二”,…};</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] strArray = &#123;<span class="string">&quot;星期一&quot;</span>,<span class="string">&quot;星期二&quot;</span>,<span class="string">&quot;星期二&quot;</span>,<span class="string">&quot;星期三&quot;</span>,<span class="string">&quot;星期四&quot;</span>,<span class="string">&quot;星期五&quot;</span>,<span class="string">&quot;星期六&quot;</span>,<span class="string">&quot;星期日&quot;</span>&#125;;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;请输入一个数据（0~6）：&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> index = sc.nextInt();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;你要查找的日期是：&quot;</span>+strArray[index]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组元素查找（查找指定元素第一次在数组中出现的索引）"><a href="#数组元素查找（查找指定元素第一次在数组中出现的索引）" class="headerlink" title="数组元素查找（查找指定元素第一次在数组中出现的索引）"></a>数组元素查找（查找指定元素第一次在数组中出现的索引）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>,<span class="number">100</span>,<span class="number">688</span>,<span class="number">666</span>,<span class="number">111</span>,<span class="number">5555</span>,<span class="number">454965</span>,<span class="number">200</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//查找200在数组中第一次出现的索引</span></span><br><span class="line">        <span class="keyword">int</span> index = getIndex(arr, <span class="number">200</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;200在数组中第一次出现的索引为：&quot;</span>+index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index2 = getIndex2(arr, <span class="number">100</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;200在数组中第一次出现的索引为：&quot;</span>+index2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法一</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getIndex</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; arr.length; x++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[x] == value) &#123;</span><br><span class="line">                <span class="keyword">return</span> x;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法二</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getIndex2</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个索引</span></span><br><span class="line">        <span class="keyword">int</span> index = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//有就修改索引值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; arr.length; x++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[x] == value) &#123;</span><br><span class="line">                index = x;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>二维数组就是一个元素为一维数组的数组</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;作者：涂祎豪&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;数组概念&quot;&gt;&lt;a href=&quot;#数组概念&quot; cl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>我的hexo-ssh秘钥</title>
    <link href="http://example.com/2020/11/08/%E6%88%91%E7%9A%84hexo-SSH/"/>
    <id>http://example.com/2020/11/08/%E6%88%91%E7%9A%84hexo-SSH/</id>
    <published>2020-11-08T02:05:46.675Z</published>
    <updated>2020-09-12T05:17:18.000Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> SSH Key: hexo</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Fingerprint: SHA256:1hLSfjvZy5aetshY2rk4Lm89THdwEF9cGmIYGOZXohg</span></span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDM6VDW9ngJhdM5eyMuUUjywiYeP9u7f93Si4FvDdobx4/b6y5dVGEay1l5Sj//Ve4WLofsMdqRZD7GL/Tbu5P+q91fVDAQieEM98JfOm2ndOPXRCpmSCeucT6yin6VGbI6K+xwwW3nleLDlJbAvozXRmv+GffTteOVX4bF0tRJ0r5pKFGnIkDDJbSjqS3NZqNjCauObrnPjPwSHFN1fYN9rO7qvcln0mgVfr1xOcDxaomKOlEDaTj/Yu0CcDNC8hmN0TKoUo3H6At957iGw5fcpzVsloaOLcrHydZFlLdZ86Hcu2hdQX/eBaIaW2tfIWvfkf2Np59aeGFs08WAqPt5 2914021718@qq.com</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>如何使用帮助文档</title>
    <link href="http://example.com/2020/11/08/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/"/>
    <id>http://example.com/2020/11/08/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3/</id>
    <published>2020-11-08T02:05:46.674Z</published>
    <updated>2020-10-04T15:29:00.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何使用帮助文档"><a href="#如何使用帮助文档" class="headerlink" title="如何使用帮助文档"></a>如何使用帮助文档</h2><ul><li><p>找到文档，打开文档</p></li><li><p>点击显示，找到索引，出现输入框</p></li><li><p>*-/你应该知道你找谁？举例：Scanner</p></li><li><p>在输入框里面输入Scanner，然后回车</p></li><li><p>看包</p><p>  java.lang包下的类不需要导入，其他的全部需要导入</p><p>  要导入：</p><p>  java.util.Scanner</p></li><li><p>再简单的看看类的解释和说明，别忘了看看该类的版本</p></li><li><p>看类的结构</p><ul><li>成员变量    字段摘要</li><li>构造方法    构造方法</li><li>成员方法    方法摘要</li></ul></li><li><p>学习构造方法</p><ul><li>有构造方法    就创建对象</li><li>没有构造方法    成员可能都是静态的</li></ul></li><li><p>看成员方法 </p><ul><li>左边<ul><li>是否静态：如果静态，可以通过类名调用</li><li>返回值类型：人家返回什么，你就用什么接收</li></ul></li><li>右边<ul><li>看方法名：方法名称不要写错</li><li>参数列表：人家要什么，你就给什么；人家要几个，你就给几个</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;如何使用帮助文档&quot;&gt;&lt;a href=&quot;#如何使用帮助文档&quot; class=&quot;headerlink&quot; title=&quot;如何使用帮助文档&quot;&gt;&lt;/a&gt;如何使用帮助文档&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;找到文档，打开文档&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;点击显示，找到索引，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2020/11/08/%E5%89%91%E6%8C%87offer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2020/11/08/%E5%89%91%E6%8C%87offer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</id>
    <published>2020-11-08T02:05:46.673Z</published>
    <updated>2020-10-09T08:18:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="剑指offer读书笔记"><a href="#剑指offer读书笔记" class="headerlink" title="剑指offer读书笔记"></a>剑指offer读书笔记</h2><h3 id="第一章-面试的流程"><a href="#第一章-面试的流程" class="headerlink" title="第一章    面试的流程"></a>第一章    面试的流程</h3><p>面试分为电话面试 – &gt;  共享桌面面试  –&gt;  现场面试三种（大多用电话面试和现场面试）</p><h4 id="1、电话面试"><a href="#1、电话面试" class="headerlink" title="1、电话面试"></a>1、电话面试</h4><p>注意点：</p><ol><li>保持手机至少有一小时（40%）以上的通话时间</li><li>尽量避免在闹市区</li><li>面试时尽可能用形象的语言把细节说清楚</li><li>千万不要答非所问，不懂装懂、</li></ol><h4 id="2、共享桌面远程面试"><a href="#2、共享桌面远程面试" class="headerlink" title="2、共享桌面远程面试"></a>2、共享桌面远程面试</h4><p>这种形式的面试，面试官最关心的是应聘者的编程习惯及调试能力。一下是常见考察的编程习惯：</p><ul><li>思考清楚再开始编码。（考虑好思路，时间复杂度，空间复杂度等等）</li><li>良好的代码命名和缩紧对齐习惯。</li><li><strong>能够单元测试。</strong>通常面试官出的题目都是要求写函数解决某一问题。应聘者能够在定义函数之后，应该对该函数进行全面的单元测试。另外，如果可以先写单元测试用例，再写解决问题的函数就更好，因为能做到测试在前、开发在后的程序员太稀有）</li><li>在共享桌面远程面试时，面试官最关心应聘者的编程习惯及调试能力</li></ul><h4 id="3、现场面试"><a href="#3、现场面试" class="headerlink" title="3、现场面试"></a>3、现场面试</h4><ul><li>出行时间，衣着准备好</li><li>注意面试</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;剑指offer读书笔记&quot;&gt;&lt;a href=&quot;#剑指offer读书笔记&quot; class=&quot;headerlink&quot; title=&quot;剑指offer读书笔记&quot;&gt;&lt;/a&gt;剑指offer读书笔记&lt;/h2&gt;&lt;h3 id=&quot;第一章-面试的流程&quot;&gt;&lt;a href=&quot;#第一章-面试的流</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>二进制、八进制、十进制、十六进制</title>
    <link href="http://example.com/2020/11/08/%E4%BA%8C%E8%BF%9B%E5%88%B6%E3%80%81%E5%85%AB%E8%BF%9B%E5%88%B6%E3%80%81%E5%8D%81%E8%BF%9B%E5%88%B6%E3%80%81%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6/"/>
    <id>http://example.com/2020/11/08/%E4%BA%8C%E8%BF%9B%E5%88%B6%E3%80%81%E5%85%AB%E8%BF%9B%E5%88%B6%E3%80%81%E5%8D%81%E8%BF%9B%E5%88%B6%E3%80%81%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6/</id>
    <published>2020-11-08T02:05:46.672Z</published>
    <updated>2020-09-26T18:05:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二进制、八进制、十进制、十六进制"><a href="#二进制、八进制、十进制、十六进制" class="headerlink" title="二进制、八进制、十进制、十六进制"></a>二进制、八进制、十进制、十六进制</h3><blockquote><p>作者：涂祎豪</p></blockquote><ul><li><p>为了能够表示更多的数据，国际化标准组织规定：用八个信号来表示一个数据，这个数据的单位叫：字节。</p></li><li><p>1byte = 8bit</p><p>  1k = 1024byte</p><p>  1m = 1024k</p><p>  1g = 1024m</p><p>  1t = 1024g</p></li></ul><h4 id="二进制转十进制"><a href="#二进制转十进制" class="headerlink" title="二进制转十进制"></a>二进制转十进制</h4><p>方法：二进制数从低位到高位（即从右往左）计算，第0位的权值是2的0次方，第1位的权值是2的1次方，第2位的权值是2的2次方，依次递增下去，把最后的结果相加的值就是十进制的值了。</p><h4 id="八进制转十进制"><a href="#八进制转十进制" class="headerlink" title="八进制转十进制"></a>八进制转十进制</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;二进制、八进制、十进制、十六进制&quot;&gt;&lt;a href=&quot;#二进制、八进制、十进制、十六进制&quot; class=&quot;headerlink&quot; title=&quot;二进制、八进制、十进制、十六进制&quot;&gt;&lt;/a&gt;二进制、八进制、十进制、十六进制&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;作</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2020/11/08/super%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88this%E5%92%8Csuper%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%89/"/>
    <id>http://example.com/2020/11/08/super%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88this%E5%92%8Csuper%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%89/</id>
    <published>2020-11-08T02:05:46.671Z</published>
    <updated>2020-10-09T11:40:10.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="super关键字（this和super的区别）"><a href="#super关键字（this和super的区别）" class="headerlink" title="super关键字（this和super的区别）"></a>super关键字（this和super的区别）</h2><h3 id="super和this分别是什么"><a href="#super和this分别是什么" class="headerlink" title="super和this分别是什么"></a>super和this分别是什么</h3><ul><li>this：代表本类对应的引用</li><li>super：代表父类存储空间的标识（可以理解为父类应用，可以操作父类的成员）</li></ul><h3 id="怎么用？"><a href="#怎么用？" class="headerlink" title="怎么用？"></a>怎么用？</h3><ul><li>调用成员变量<ul><li>this.成员变量    调用本类的成员变量</li><li>super.成员变量    调用父类的成员变量</li></ul></li><li>调用构造方法<ul><li>this (  .  .  .  )     调用本类的构造方法</li><li>super (  .  .  .  )     调用父类的构造方法</li></ul></li><li>调用成员方法<ul><li>this.成员方法    调用本类的成员方法</li><li>super.成员方法    调用父类的成员方法</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;super关键字（this和super的区别）&quot;&gt;&lt;a href=&quot;#super关键字（this和super的区别）&quot; class=&quot;headerlink&quot; title=&quot;super关键字（this和super的区别）&quot;&gt;&lt;/a&gt;super关键字（this和sup</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>static关键字</title>
    <link href="http://example.com/2020/11/08/static%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://example.com/2020/11/08/static%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2020-11-08T02:05:46.670Z</published>
    <updated>2020-10-04T14:35:26.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h2><h3 id="static的特点"><a href="#static的特点" class="headerlink" title="static的特点"></a>static的特点</h3><ul><li>随着类的加载而加载</li><li>优先于对象存在</li><li>被类的所有对象共享<ul><li>这也是我们判断是否使用静态关键字的条件</li></ul></li><li>可以通过类名调用</li></ul><h3 id="static关键字注意事项"><a href="#static关键字注意事项" class="headerlink" title="static关键字注意事项"></a>static关键字注意事项</h3><ul><li><p>在静态方法中是没有this关键字的</p></li><li><p>静态方法只能访问静态的成员变量和静态的成员方法</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;static关键字&quot;&gt;&lt;a href=&quot;#static关键字&quot; class=&quot;headerlink&quot; title=&quot;static关键字&quot;&gt;&lt;/a&gt;static关键字&lt;/h2&gt;&lt;h3 id=&quot;static的特点&quot;&gt;&lt;a href=&quot;#static的特点&quot; class</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>牛客网数据库SQL实战</title>
    <link href="http://example.com/2020/11/08/sql%E7%BB%83%E4%B9%A0/"/>
    <id>http://example.com/2020/11/08/sql%E7%BB%83%E4%B9%A0/</id>
    <published>2020-11-08T02:05:46.669Z</published>
    <updated>2020-09-26T18:06:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="牛客网数据库SQL实战（持续更新）"><a href="#牛客网数据库SQL实战（持续更新）" class="headerlink" title="牛客网数据库SQL实战（持续更新）"></a>牛客网数据库SQL实战（持续更新）</h3><blockquote><p>作者：涂祎豪</p></blockquote><h4 id="1、查找最晚入职员工的所有信息"><a href="#1、查找最晚入职员工的所有信息" class="headerlink" title="1、查找最晚入职员工的所有信息"></a>1、查找最晚入职员工的所有信息</h4><p><strong>题目描述</strong></p><p>查找最晚入职员工的所有信息，为了减轻入门难度，目前所有的数据里员工入职的日期都不是同一天(sqlite里面的注释为–,mysql为comment)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;employees&#96; (</span><br><span class="line">&#96;emp_no&#96; int(11) NOT NULL, -- &#39;员工编号&#39;</span><br><span class="line">&#96;birth_date&#96; date NOT NULL,</span><br><span class="line">&#96;first_name&#96; varchar(14) NOT NULL,</span><br><span class="line">&#96;last_name&#96; varchar(16) NOT NULL,</span><br><span class="line">&#96;gender&#96; char(1) NOT NULL,</span><br><span class="line">&#96;hire_date&#96; date NOT NULL,</span><br><span class="line">PRIMARY KEY (&#96;emp_no&#96;));</span><br></pre></td></tr></table></figure><p><strong>输入描述:</strong></p><blockquote><p>无</p></blockquote><p><strong>输出描述：</strong></p><blockquote><table><thead><tr><th align="left">emp_no</th><th align="left">birth_date</th><th align="left">first_name</th><th align="left">last_name</th><th align="left">gender</th><th align="left">hire_date</th></tr></thead><tbody><tr><td align="left">10008</td><td align="left">1958-02-19</td><td align="left">Saniya</td><td align="left">Kalloufi</td><td align="left">M</td><td align="left">1994-09-15</td></tr></tbody></table></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM employees</span><br><span class="line">WHERE hire_date &#x3D; (SELECT MAX(hire_date) FROM employees)</span><br></pre></td></tr></table></figure><h4 id="2、查找入职员工时间排名倒数第三的员工所有信息"><a href="#2、查找入职员工时间排名倒数第三的员工所有信息" class="headerlink" title="2、查找入职员工时间排名倒数第三的员工所有信息"></a>2、查找入职员工时间排名倒数第三的员工所有信息</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;牛客网数据库SQL实战（持续更新）&quot;&gt;&lt;a href=&quot;#牛客网数据库SQL实战（持续更新）&quot; class=&quot;headerlink&quot; title=&quot;牛客网数据库SQL实战（持续更新）&quot;&gt;&lt;/a&gt;牛客网数据库SQL实战（持续更新）&lt;/h3&gt;&lt;blockquote&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>PicGo、Typora联合阿里云OSS图床</title>
    <link href="http://example.com/2020/11/08/PicGo%E3%80%81Typora%E8%81%94%E5%90%88%E9%98%BF%E9%87%8C%E4%BA%91OSS%E5%9B%BE%E5%BA%8A/"/>
    <id>http://example.com/2020/11/08/PicGo%E3%80%81Typora%E8%81%94%E5%90%88%E9%98%BF%E9%87%8C%E4%BA%91OSS%E5%9B%BE%E5%BA%8A/</id>
    <published>2020-11-08T02:05:46.668Z</published>
    <updated>2020-09-10T07:18:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="PicGo、Typora联合阿里云OSS图床"><a href="#PicGo、Typora联合阿里云OSS图床" class="headerlink" title="PicGo、Typora联合阿里云OSS图床"></a>PicGo、Typora联合阿里云OSS图床</h3><blockquote><p>作者：涂祎豪</p></blockquote><ol><li><p>下载PicGo</p></li><li><p>注册阿里云OSS</p></li><li><p>设置PicGo</p><p> <img src= "/img/loading.gif" data-lazy-src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/20200908220912.png" alt="image-20200908213036099"></p></li><li><p>设置Typora</p><p> <img src= "/img/loading.gif" data-lazy-src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/20200908220920.png" alt="image-20200908213206333"></p></li><li><p>完成</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;PicGo、Typora联合阿里云OSS图床&quot;&gt;&lt;a href=&quot;#PicGo、Typora联合阿里云OSS图床&quot; class=&quot;headerlink&quot; title=&quot;PicGo、Typora联合阿里云OSS图床&quot;&gt;&lt;/a&gt;PicGo、Typora联合阿里云OSS</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Neo4j入门学习</title>
    <link href="http://example.com/2020/11/08/Neo4j%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2020/11/08/Neo4j%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-11-08T02:05:46.667Z</published>
    <updated>2020-09-26T19:51:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Neo4j入门学习"><a href="#Neo4j入门学习" class="headerlink" title="Neo4j入门学习"></a>Neo4j入门学习</h2><blockquote><p>作者：涂祎豪</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJQUzI1NiIsInR5cCI6IkpXVCJ9.eyJjYWxsYmFjayI6IiIsImVtYWlsIjoiLitALisiLCJmb3JtYXQiOiJqc29uIiwib3JnIjoiLioiLCJwdWIiOiJuZW80ai5jb20iLCJyZWciOiIgIiwic3ViIjoibmVvNGotZGVza3RvcCIsImV4cCI6MTYzMjY4MDM3OCwidmVyIjoiKiIsImlzcyI6Im5lbzRqLmNvbSIsIm5iZiI6MTYwMTE0NDM3OCwiaWF0IjoxNjAxMTQ0Mzc4LCJqdGkiOiJjb0hpcGRLSFIifQ.bEA3C4CwJc609Tt84qsdRoG1lCB2-lBbzroXLJFYe5jUtNgDNJvmV6hARvPcdrzU5iyWmRekytiE3M6kXrzs5WL9nj2qNZEpSHDgKrKsBUIciG_XcjEoz67MJRUzc6zVQEVyQ3zbIsRCZj_R_LVkAUnIjn_BQtqkuqSa-95-w5MdDgBWYvnG9KfJUOSkVyKWUcYVTIphNF8MVeTvpbkyZVwaLLxkg7gwU2vdYS8bdrOhw0h5gLXliHmGEYyzMBfRFIQK6xJFJCoaHjrXCOM7p9mpQ-gb-fAnH96kzEkPo-TsHmtWR9GKK9G6iK0uxcTRuHizz_OP2QemjyqdTltYzg</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/20200927034018.png" alt="image-20200927034018491"></p><p><img src= "/img/loading.gif" data-lazy-src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/20200927034102.png" alt="image-20200927034102464"></p><p><img src= "/img/loading.gif" data-lazy-src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/20200927034235.png" alt="image-20200927034234995"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Neo4j入门学习&quot;&gt;&lt;a href=&quot;#Neo4j入门学习&quot; class=&quot;headerlink&quot; title=&quot;Neo4j入门学习&quot;&gt;&lt;/a&gt;Neo4j入门学习&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;作者：涂祎豪&lt;/p&gt;
&lt;/blockquote&gt;
&lt;fig</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Navicat远程连接阿里云报错</title>
    <link href="http://example.com/2020/11/08/Navicat%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E9%98%BF%E9%87%8C%E4%BA%91%E6%8A%A5%E9%94%99/"/>
    <id>http://example.com/2020/11/08/Navicat%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E9%98%BF%E9%87%8C%E4%BA%91%E6%8A%A5%E9%94%99/</id>
    <published>2020-11-08T02:05:46.666Z</published>
    <updated>2020-09-26T18:07:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Navicat远程连接阿里云报错"><a href="#Navicat远程连接阿里云报错" class="headerlink" title="Navicat远程连接阿里云报错"></a>Navicat远程连接阿里云报错</h3><blockquote><p>作者：涂祎豪</p></blockquote><ol><li><p>查看阿里云、宝塔是否都打开了3306访问权限</p></li><li><p>赋予账号远程登录权限</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grant all privileges on *.* to &#39;用户&#39;@&#39;ip&#39; identified by &#39;密码&#39; with grant option;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><p> 第一句语句语句中，*.*代表所有库表，若想给予所有IP权限，”ip”写成“%”,所以第一句sql的意思是给予来自所有IP地址的通过“用户”，“密码”登录的用户对所有库表的所有操作权限。<br> 第二句sql，刷新权限。<br> 然后同样重启MySQL生效。</p></li><li><p>测试成功</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Navicat远程连接阿里云报错&quot;&gt;&lt;a href=&quot;#Navicat远程连接阿里云报错&quot; class=&quot;headerlink&quot; title=&quot;Navicat远程连接阿里云报错&quot;&gt;&lt;/a&gt;Navicat远程连接阿里云报错&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;作</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL必知必会50题</title>
    <link href="http://example.com/2020/11/08/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A50%E9%A2%98/"/>
    <id>http://example.com/2020/11/08/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A50%E9%A2%98/</id>
    <published>2020-11-08T02:05:46.665Z</published>
    <updated>2020-09-26T18:05:40.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="MySQL必知必会50题"><a href="#MySQL必知必会50题" class="headerlink" title="MySQL必知必会50题"></a>MySQL必知必会50题</h3><blockquote><p>作者：涂祎豪</p></blockquote><h4 id="1-新建数据库"><a href="#1-新建数据库" class="headerlink" title="1. 新建数据库"></a>1. 新建数据库</h4><p>数据库属性 utf – UTF-8 Unicode</p><p>排序规则 utf8_unicode_ci</p><p><img src= "/img/loading.gif" data-lazy-src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/20200921181333.png" alt="image-20200921181258269"></p><h4 id="2-建表"><a href="#2-建表" class="headerlink" title="2. 建表"></a>2. 建表</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">-- 学生表</span><br><span class="line">-- Student (s_id, s_name, s_birth, s_sex)</span><br><span class="line">-- 学生编号，学生姓名，出生年月，学生</span><br><span class="line">create table Student(</span><br><span class="line">s_id VARCHAR(20),</span><br><span class="line">s_name VARCHAR(20) not null DEFAULT &#39;&#39;,</span><br><span class="line">s_birth VARCHAR(20) not null DEFAULT &#39;&#39;,</span><br><span class="line">s_sex VARCHAR(10) not null DEFAULT &#39;&#39;,</span><br><span class="line">PRIMARY KEY(s_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 课程表</span><br><span class="line">-- Course(c_id, c_name, t_id)</span><br><span class="line">-- 课程编号，课程名称，教师编号</span><br><span class="line">create table Course(</span><br><span class="line">c_id VARCHAR(20),</span><br><span class="line">c_name VARCHAR(20) not null DEFAULT &#39;&#39;,</span><br><span class="line">t_id VARCHAR(20) not null,</span><br><span class="line">PRIMARY KEY(c_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 教师表</span><br><span class="line">-- Teacher(t_id, t_name)</span><br><span class="line">-- 教师编号，教师姓名</span><br><span class="line">create table Teacher(</span><br><span class="line">t_id VARCHAR(20),</span><br><span class="line">t_name VARCHAR(20) not null DEFAULT &#39;&#39;,</span><br><span class="line">PRIMARY KEY(t_id)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">-- 成绩表</span><br><span class="line">-- Score(s_id, c_id, s_score)</span><br><span class="line">-- 学生编号，课程编号，分数</span><br><span class="line">create table Score(</span><br><span class="line">s_id VARCHAR(20),</span><br><span class="line">c_id VARCHAR(20),</span><br><span class="line">s_score INT(3),</span><br><span class="line">PRIMARY KEY(s_id, c_id)</span><br><span class="line">);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="3-插入数据"><a href="#3-插入数据" class="headerlink" title="3. 插入数据"></a>3. 插入数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">-- 插入数据</span><br><span class="line"></span><br><span class="line">-- 学生表数据</span><br><span class="line">insert into Student values(&#39;01&#39; , &#39;赵雷&#39; , &#39;1990-01-01&#39; , &#39;男&#39;);</span><br><span class="line">insert into Student values(&#39;02&#39; , &#39;钱电&#39; , &#39;1990-12-21&#39; , &#39;男&#39;);</span><br><span class="line">insert into Student values(&#39;03&#39; , &#39;孙风&#39; , &#39;1990-05-20&#39; , &#39;男&#39;);</span><br><span class="line">insert into Student values(&#39;04&#39; , &#39;李云&#39; , &#39;1990-08-06&#39; , &#39;男&#39;);</span><br><span class="line">insert into Student values(&#39;05&#39; , &#39;周梅&#39; , &#39;1991-12-01&#39; , &#39;女&#39;);</span><br><span class="line">insert into Student values(&#39;06&#39; , &#39;吴兰&#39; , &#39;1992-03-01&#39; , &#39;女&#39;);</span><br><span class="line">insert into Student values(&#39;07&#39; , &#39;郑竹&#39; , &#39;1989-07-01&#39; , &#39;女&#39;);</span><br><span class="line">insert into Student values(&#39;08&#39; , &#39;王菊&#39; , &#39;1990-01-20&#39; , &#39;女&#39;);</span><br><span class="line"></span><br><span class="line">-- 课程表数据</span><br><span class="line">insert into Course values(&#39;01&#39; , &#39;语文&#39; , &#39;02&#39;);</span><br><span class="line">insert into Course values(&#39;02&#39; , &#39;数学&#39; , &#39;01&#39;);</span><br><span class="line">insert into Course values(&#39;03&#39; , &#39;英语&#39; , &#39;03&#39;);</span><br><span class="line"></span><br><span class="line">-- 教师表数据</span><br><span class="line">insert into Teacher values(&#39;01&#39; , &#39;张三&#39;);</span><br><span class="line">insert into Teacher values(&#39;02&#39; , &#39;李四&#39;);</span><br><span class="line">insert into Teacher values(&#39;03&#39; , &#39;王五&#39;);</span><br><span class="line"></span><br><span class="line">-- 成绩表数据</span><br><span class="line">insert into Score values(&#39;01&#39; , &#39;01&#39; , 80);</span><br><span class="line">insert into Score values(&#39;01&#39; , &#39;02&#39; , 90);</span><br><span class="line">insert into Score values(&#39;01&#39; , &#39;03&#39; , 99);</span><br><span class="line">insert into Score values(&#39;02&#39; , &#39;01&#39; , 70);</span><br><span class="line">insert into Score values(&#39;02&#39; , &#39;02&#39; , 60);</span><br><span class="line">insert into Score values(&#39;02&#39; , &#39;03&#39; , 80);</span><br><span class="line">insert into Score values(&#39;03&#39; , &#39;01&#39; , 80);</span><br><span class="line">insert into Score values(&#39;03&#39; , &#39;02&#39; , 80);</span><br><span class="line">insert into Score values(&#39;03&#39; , &#39;03&#39; , 80);</span><br><span class="line">insert into Score values(&#39;04&#39; , &#39;01&#39; , 50);</span><br><span class="line">insert into Score values(&#39;04&#39; , &#39;02&#39; , 30);</span><br><span class="line">insert into Score values(&#39;04&#39; , &#39;03&#39; , 20);</span><br><span class="line">insert into Score values(&#39;05&#39; , &#39;01&#39; , 76);</span><br><span class="line">insert into Score values(&#39;05&#39; , &#39;02&#39; , 87);</span><br><span class="line">insert into Score values(&#39;06&#39; , &#39;01&#39; , 31);</span><br><span class="line">insert into Score values(&#39;06&#39; , &#39;03&#39; , 34);</span><br><span class="line">insert into Score values(&#39;07&#39; , &#39;02&#39; , 89);</span><br><span class="line">insert into Score values(&#39;07&#39; , &#39;03&#39; , 98);</span><br></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/20200921184316.png" alt="image-20200921184315099"></p><h4 id="4-题目"><a href="#4-题目" class="headerlink" title="4. 题目"></a>4. 题目</h4><h5 id="1-查询课程编号为‘01’的课程比‘02’的课程成绩高的所有学生的学号、姓名和各自‘01’‘02’课程成绩"><a href="#1-查询课程编号为‘01’的课程比‘02’的课程成绩高的所有学生的学号、姓名和各自‘01’‘02’课程成绩" class="headerlink" title="1. 查询课程编号为‘01’的课程比‘02’的课程成绩高的所有学生的学号、姓名和各自‘01’‘02’课程成绩"></a>1. 查询课程编号为‘01’的课程比‘02’的课程成绩高的所有学生的学号、姓名和各自‘01’‘02’课程成绩</h5><p><strong>思路：</strong>通过学生编号将成绩表的课程‘01’成绩和课程‘02’成绩构建一张新表包含：学生表、课程‘01’成绩、课程‘02’成绩<br><strong>关键函数：</strong>select…FROM…INNER JOIN…ON…WHERE…</p><p><strong>解题语句：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select a.s_id 学号, c.s_name 姓名, a.s_score &#39;01成绩&#39;, b.s_score &#39;02 成绩&#39;FROM</span><br><span class="line">(select s_id, c_id, s_score from score where c_id &#x3D; 01) as a</span><br><span class="line">inner join </span><br><span class="line">(select s_id, c_id, s_score from score where c_id &#x3D; 02) as b</span><br><span class="line">on a.s_id &#x3D; b.s_id</span><br><span class="line">inner join student as c </span><br><span class="line">on a.s_id&#x3D;c.s_id</span><br><span class="line">where a.s_score&gt;b.s_score;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/20200927013957.png" alt="image-20200927013957737"></p><h5 id="2-查询平均成绩大于60分的学生的学号和平均成绩"><a href="#2-查询平均成绩大于60分的学生的学号和平均成绩" class="headerlink" title="2. 查询平均成绩大于60分的学生的学号和平均成绩"></a>2. 查询平均成绩大于60分的学生的学号和平均成绩</h5><p><strong>思路：</strong>以学生学号进行分组，算平均分，筛选数据平均成绩大于60分的学生学号和平均成绩</p><p><strong>关键函数：</strong>group by, avg()</p><p><strong>解题语句：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select s_id 学号, avg(s_score) 平均分</span><br><span class="line">from score</span><br><span class="line">group by s_id</span><br><span class="line">having avg(s_score) &gt; 60;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/20200927014037.png" alt="image-20200927014037405"></p><h5 id="3-查询所有学生的学号、姓名、选课数、总成绩"><a href="#3-查询所有学生的学号、姓名、选课数、总成绩" class="headerlink" title="3. 查询所有学生的学号、姓名、选课数、总成绩"></a>3. 查询所有学生的学号、姓名、选课数、总成绩</h5><p><strong>思路：</strong>学生表通过学生号做关联成绩表，以学生学号进行分组，count函数计算选课数，sum函数计算总成绩，ifnull函数将由于做关联产生的成绩中没有的同学数据null编程0</p><p><strong>解题语句：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select stu.s_id 学号, stu.s_name 姓名, count(sco.c_id) 选课数, sum(ifnull(sco.s_score,0)) 总成绩</span><br><span class="line">from student stu</span><br><span class="line">left join score sco</span><br><span class="line">on stu.s_id &#x3D; sco.s_id</span><br><span class="line">group by stu.s_id;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/20200927014240.png" alt="image-20200927014240181"></p><h5 id="4-查询姓张的老师的个数"><a href="#4-查询姓张的老师的个数" class="headerlink" title="4. 查询姓张的老师的个数"></a>4. 查询姓张的老师的个数</h5><p><strong>思路：</strong>用like筛选老师姓名，避免姓名重复通过计算老师id来计算个数</p><p><strong>关键函数：</strong>like， count</p><p><strong>解题语句：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select count(t_id) 姓张的老师的个数</span><br><span class="line">from teacher</span><br><span class="line">where t_name like &#39;张%&#39;;</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/20200927014650.png" alt="image-20200927014649978"></p><h5 id="5-查询没学过“张三”老师课的学生的学号、姓名"><a href="#5-查询没学过“张三”老师课的学生的学号、姓名" class="headerlink" title="5. 查询没学过“张三”老师课的学生的学号、姓名"></a>5. 查询没学过“张三”老师课的学生的学号、姓名</h5><p><strong>思路1：</strong>多层嵌套、子查询</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;MySQL必知必会50题&quot;&gt;&lt;a href=&quot;#MySQL必知必会50题&quot; class=&quot;headerlink&quot; title=&quot;MySQL必知必会50题&quot;&gt;&lt;/a&gt;MySQL必知必会50题&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;作者：涂祎豪&lt;/p&gt;
&lt;/bloc</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>CentOS7下mysql5.7忘记密码处理方法</title>
    <link href="http://example.com/2020/11/08/mysql%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/"/>
    <id>http://example.com/2020/11/08/mysql%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/</id>
    <published>2020-11-08T02:05:46.664Z</published>
    <updated>2020-09-26T18:07:18.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CentOS7下mysql5-7忘记密码处理方法"><a href="#CentOS7下mysql5-7忘记密码处理方法" class="headerlink" title="CentOS7下mysql5.7忘记密码处理方法"></a>CentOS7下mysql5.7忘记密码处理方法</h3><blockquote><p>作者：涂祎豪</p></blockquote><ol><li><p>停止mysql服务</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service mysqld stop</span><br></pre></td></tr></table></figure></li><li><p>修改配置文件 /etc/my.cnf</p><p> 在[mysqld]下添加</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skip-grant-tables</span><br></pre></td></tr></table></figure><p> 意思是忽略密码</p><p> 保存并退出</p></li><li><p>启动Mysql</p><p> service mysqld start</p></li><li><p>免密码登录</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root</span><br></pre></td></tr></table></figure></li><li><p>进入数据库 </p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use mysql</span><br></pre></td></tr></table></figure></li><li><p>修改root密码</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update user set authentication_string &#x3D; password(&#39;新密码&#39;),password_last_changed&#x3D;now() where user&#x3D;&#39;root&#39;;</span><br></pre></td></tr></table></figure></li><li><p>退出数据库</p></li><li><p>再次配置文件 <code>/etc/my.cnf</code> 删除 <code>skip-grant-tables</code> 保存退出</p></li><li><p>重启mysql服务器</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;CentOS7下mysql5-7忘记密码处理方法&quot;&gt;&lt;a href=&quot;#CentOS7下mysql5-7忘记密码处理方法&quot; class=&quot;headerlink&quot; title=&quot;CentOS7下mysql5.7忘记密码处理方法&quot;&gt;&lt;/a&gt;CentOS7下mysql5</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MySQL学习</title>
    <link href="http://example.com/2020/11/08/mysql/"/>
    <id>http://example.com/2020/11/08/mysql/</id>
    <published>2020-11-08T02:05:46.663Z</published>
    <updated>2020-09-13T07:28:44.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL学习（持续更新）"><a href="#MySQL学习（持续更新）" class="headerlink" title="MySQL学习（持续更新）"></a>MySQL学习（持续更新）</h2><blockquote><p>作者：涂祎豪</p></blockquote><h3 id="1、初识别MySQL"><a href="#1、初识别MySQL" class="headerlink" title="1、初识别MySQL"></a>1、初识别MySQL</h3><hr><h4 id="1-1-为什么学习数据库"><a href="#1-1-为什么学习数据库" class="headerlink" title="1.1 为什么学习数据库"></a>1.1 为什么学习数据库</h4><p>1、岗位技能需求<br>2、现在的世界,得数据者得天下<br>3、存储数据的方法<br>4、程序,网站中,大量数据如何长久保存?<br><strong>5、数据库是几乎软件体系中最核心的一个存在。</strong></p><h4 id="1-2、什么是数据库"><a href="#1-2、什么是数据库" class="headerlink" title="1.2、什么是数据库"></a>1.2、什么是数据库</h4><p>数据库 ( DataBase , 简称DB )</p><p><strong>概念 :</strong> 长期存放在计算机内,有组织,可共享的大量数据的集合,是一个数据 “仓库”</p><p><strong>作用 :</strong> 保存,并能安全管理数据(如:增删改查等),减少冗余…</p><p><strong>数据库总览 :</strong></p><ul><li>关系型数据库 ( SQL )<ul><li>MySQL , Oracle , SQL Server , SQLite , DB2 , …</li><li>关系型数据库通过外键关联来建立表与表之间的关系</li></ul></li><li>非关系型数据库 ( NOSQL )<ul><li>Redis , MongoDB , …</li><li>非关系型数据库通常指数据以对象的形式存储在数据库中，而对象之间的关系通过每个对象自身的属性来决定</li></ul></li></ul><h4 id="1-3-什么是DBMS"><a href="#1-3-什么是DBMS" class="headerlink" title="1.3 什么是DBMS"></a>1.3 什么是DBMS</h4><p>数据库管理系统 ( DataBase Management System )</p><p>数据库管理软件 , 科学组织和存储数据 , 高效地获取和维护数据</p><p><img src= "/img/loading.gif" data-lazy-src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/20200912234104.png" alt="image-20200912234104207"></p><p>MySQL算是一个数据库管理系统</p><h4 id="1-4、MySQL简介"><a href="#1-4、MySQL简介" class="headerlink" title="1.4、MySQL简介"></a>1.4、MySQL简介</h4><p><img src= "/img/loading.gif" data-lazy-src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/20200913000120.png" alt="image-20200913000118956"></p><p><strong>概念 :</strong> 是现在流行的开源的,免费的 关系型数据库</p><p><strong>历史 :</strong> 由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。</p><p><strong>特点 :</strong></p><ul><li>免费 , 开源数据库</li><li>小巧 , 功能齐全</li><li>使用便捷</li><li>可运行于Windows或Linux操作系统</li><li>可适用于中小型甚至大型网站应用</li></ul><p><strong>官网</strong> : <a href="https://www.mysql.com/">https://www.mysql.com/</a></p><h4 id="1-5、安装MySQL"><a href="#1-5、安装MySQL" class="headerlink" title="1.5、安装MySQL"></a>1.5、安装MySQL</h4><p>很简单，脑残式安装</p><h4 id="1-6-Navicat"><a href="#1-6-Navicat" class="headerlink" title="1.6 Navicat"></a>1.6 Navicat</h4><p>可手动操作,管理MySQL数据库的软件工具</p><p>特点 : 简洁 , 易用 , 图形化</p><h4 id="1-7、连接数据库"><a href="#1-7、连接数据库" class="headerlink" title="1.7、连接数据库"></a>1.7、连接数据库</h4><p>略</p><h3 id="2、操作数据库"><a href="#2、操作数据库" class="headerlink" title="2、操作数据库"></a>2、操作数据库</h3><hr><h4 id="2-1、结构化查询语句分类"><a href="#2-1、结构化查询语句分类" class="headerlink" title="2.1、结构化查询语句分类"></a>2.1、结构化查询语句分类</h4><table><thead><tr><th>名称</th><th>解释</th><th>命令</th></tr></thead><tbody><tr><td>DDL（数据定义语言）</td><td>定义和管理数据对象，如数据库，数据表等</td><td>CREATE、DROP、ALTER</td></tr><tr><td>DML（数据操作语言）</td><td>用于操作数据库对象中所包含的数据</td><td>INSERT、UPDATE、DELETE</td></tr><tr><td>DQL（数据查询语言）</td><td>用于查询数据库数据</td><td>SELECT</td></tr><tr><td>DCL（数据控制语言）</td><td>用于管理数据库的语言，包括管理权限及数据更改</td><td>GRANT、commit、rollback</td></tr></tbody></table><h4 id="2-2、数据库操作"><a href="#2-2、数据库操作" class="headerlink" title="2.2、数据库操作"></a>2.2、数据库操作</h4><blockquote><p>命令行操作数据</p></blockquote><p>创建数据库：<code>create database [if not exists] 数据库名;</code></p><p>删除数据库：<code>drop database [if exists] 数据库名;</code></p><p>查看数据库：<code>show databases;</code></p><p>使用数据库：<code>use 数据库名;</code></p><blockquote><p>对比工具操作数据库</p></blockquote><p><strong>学习方法：</strong></p><ul><li>对照SQLyog工具自动生成的语句学习</li><li>固定语法中的单词需要记忆</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/20200913012051.png" alt="image-20200913012051345"></p><h4 id="2-3、创建数据表"><a href="#2-3、创建数据表" class="headerlink" title="2.3、创建数据表"></a>2.3、创建数据表</h4><p>属于DDL的一种，语法 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">create table [if not exists] &#96;表名&#96;(</span><br><span class="line">&#39;字段名1&#39; 列类型 [属性][索引][注释],</span><br><span class="line">&#39;字段名2&#39; 列类型 [属性][索引][注释],</span><br><span class="line">#...</span><br><span class="line">&#39;字段名n&#39; 列类型 [属性][索引][注释]</span><br><span class="line">)[表类型][表字符集][注释];</span><br></pre></td></tr></table></figure><p>说明 : 反引号用于区别MySQL保留字与普通字符而引入的 (键盘esc下面的键).</p><h4 id="2-4、数据值和列类型"><a href="#2-4、数据值和列类型" class="headerlink" title="2.4、数据值和列类型"></a>2.4、数据值和列类型</h4><p>列类型 : 规定数据库中该列存放的数据类型</p><blockquote><p>数值类型</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/20200913012337.png" alt="image-20200913012337182"></p><blockquote><p>字符串类型</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/20200913012357.png" alt="image-20200913012357776"></p><blockquote><p>日期和时间型数值类型</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/20200913013302.png" alt="image-20200913013302734"></p><blockquote><p>NULL值</p></blockquote><ul><li>理解为 “没有值” 或 “未知值”</li><li>不要用NULL进行算术运算 , 结果仍为NULL</li></ul><h4 id="2-5、数据字段属性"><a href="#2-5、数据字段属性" class="headerlink" title="2.5、数据字段属性"></a>2.5、数据字段属性</h4><p><font color='FF0000'><strong>UnSigned</strong></font></p><ul><li>无符号的</li><li>声明该数据列不允许负数 .</li></ul><p><font color='FF0000'><strong>ZEROFILL</strong></font></p><ul><li>0填充的</li><li>不足位数的用0来填充 , 如int(3),5则为005</li></ul><p><font color='FF0000'><strong>Auto_InCrement</strong></font></p><ul><li>自动增长的 , 每添加一条数据 , 自动在上一个记录数上加 1(默认)</li><li>通常用于设置主键 , 且为整数类型</li><li>可定义起始值和步长<ul><li>当前表设置步长(AUTO_INCREMENT=100) : 只影响当前表</li><li>SET @@auto_increment_increment=5 ; 影响所有使用自增的表(全局)</li></ul></li></ul><p><font color='FF0000'><strong>NULL 和 NOT NULL</strong></font></p><ul><li>默认为NULL , 即没有插入该列的数值</li><li>如果设置为NOT NULL , 则该列必须有值</li></ul><p><font color='FF0000'><strong>DEFAULT</strong></font></p><ul><li>默认的</li><li>用于设置默认值</li><li>例如,性别字段,默认为”男” , 否则为 “女” ; 若无指定该列的值 , 则默认值为”男”的值</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">-- 目标 : 创建一个school数据库</span><br><span class="line">-- 创建学生表(列,字段)</span><br><span class="line">-- 学号int 登录密码varchar(20) 姓名,性别varchar(2),出生日期(datatime),家庭住</span><br><span class="line">址,email</span><br><span class="line">-- 创建表之前 , 一定要先选择数据库</span><br><span class="line">CREATE TABLE IF NOT EXISTS &#96;student&#96; (</span><br><span class="line">    &#96;id&#96; int(4) NOT NULL AUTO_INCREMENT COMMENT &#39;学号&#39;,</span><br><span class="line">    &#96;name&#96; varchar(30) NOT NULL DEFAULT &#39;匿名&#39; COMMENT &#39;姓名&#39;,</span><br><span class="line">    &#96;pwd&#96; varchar(20) NOT NULL DEFAULT &#39;123456&#39; COMMENT &#39;密码&#39;,</span><br><span class="line">    &#96;sex&#96; varchar(2) NOT NULL DEFAULT &#39;男&#39; COMMENT &#39;性别&#39;,</span><br><span class="line">    &#96;birthday&#96; datetime DEFAULT NULL COMMENT &#39;生日&#39;,</span><br><span class="line">    &#96;address&#96; varchar(100) DEFAULT NULL COMMENT &#39;地址&#39;,</span><br><span class="line">    &#96;email&#96; varchar(50) DEFAULT NULL COMMENT &#39;邮箱&#39;,</span><br><span class="line">PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB DEFAULT CHARSET&#x3D;utf8</span><br><span class="line">-- 查看数据库的定义</span><br><span class="line">SHOW CREATE DATABASE school;</span><br><span class="line">-- 查看数据表的定义</span><br><span class="line">SHOW CREATE TABLE student;</span><br><span class="line">-- 显示表结构</span><br><span class="line">DESC student; -- 设置严格检查模式(不能容错了)SET</span><br><span class="line">sql_mode&#x3D;&#39;STRICT_TRANS_TABLES&#39;;</span><br></pre></td></tr></table></figure><h4 id="2-6、数据表的类型"><a href="#2-6、数据表的类型" class="headerlink" title="2.6、数据表的类型"></a>2.6、数据表的类型</h4><blockquote><p>设置数据表的类型</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">    -- 省略一些代码</span><br><span class="line">    -- Mysql注释</span><br><span class="line">    -- 1. # 单行注释</span><br><span class="line">    -- 2. &#x2F;*...*&#x2F; 多行注释</span><br><span class="line">)ENGINE &#x3D; MyISAM (or InnoDB)</span><br><span class="line">-- 查看mysql所支持的引擎类型 (表类型)</span><br><span class="line">SHOW ENGINES;</span><br></pre></td></tr></table></figure><p>MySQL的数据表的类型 : <strong>MyISAM , InnoDB</strong> , HEAP , BOB , CSV等…</p><p>常见的 MyISAM 与 InnoDB 类型：</p><p><img src= "/img/loading.gif" data-lazy-src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/20200913021444.png" alt="image-20200913021444744"></p><p>经验 ( 适用场合 ) :</p><ul><li>适用 MyISAM : 节约空间及相应速度</li><li>适用 InnoDB : 安全性 , 事务处理及多用户操作数据表</li></ul><blockquote><p>数据表的存储位置</p></blockquote><ul><li><p>MySQL数据表以文件方式存放在磁盘中</p><ul><li>包括表文件 , 数据文件 , 以及数据库的选项文件</li><li>位置 : Mysql安装目录\data\下存放数据表 . 目录名对应数据库名 , 该目录下文件名对应数据表</li></ul></li><li><p>注意：</p><ul><li>InnoDB类型数据表只有一个 *.frm文件 , 以及上一级目录的ibdata1文件</li><li>MyISAM类型数据表对应三个文件 :<ul><li>. frm – 表结构定义文件</li><li>. MYD – 数据文件 ( data )</li><li>. MYI – 索引文件 ( index )</li></ul></li><li><img src= "/img/loading.gif" data-lazy-src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/20200913110856.png" alt="image-20200913110856737"></li></ul></li></ul><blockquote><p>设置数据表字符集</p></blockquote><p>我们可为数据库,数据表,数据列设定不同的字符集，设定方法 :</p><ul><li>创建时通过命令来设置 , 如 : ==CREATE TABLE 表名()CHARSET = utf8;==</li><li>如无设定 , 则根据MySQL数据库配置文件 ==my.ini== 中的参数设定</li></ul><h4 id="2-7、修改数据库"><a href="#2-7、修改数据库" class="headerlink" title="2.7、修改数据库"></a>2.7、修改数据库</h4><blockquote><p>修改表（ALTER TABLE)</p></blockquote><p>修改表名：<code>ALTER TABLE 旧表名 RENAME AS 新表名</code></p><p>添加字段：<code>ATER TABLE 表名 CHANDE 就字段名 新字段名 列属性[属性]</code></p><p>修改字段：</p><ul><li><code>ALTER TABLE 表名 MODIFY 字段名 列类型[属性]</code></li><li><code>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 列属性[属性]</code></li></ul><p>删除字段：<code>ALTER TABLE 表名 DROP 字段名</code></p><blockquote><p>删除数据表</p></blockquote><p>语法：<code>drop table [if exists] 表名</code></p><ul><li><code>if exists</code>为可选，判断是否存在该数据表</li><li>如果删除不存在的数据表会抛出错误</li></ul><blockquote><p>其他</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1. 可用反引号（&#96;）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文</span><br><span class="line">也可以作为标识符！</span><br><span class="line"></span><br><span class="line">2. 每个库目录存在一个保存当前数据库的选项文件db.opt。</span><br><span class="line"></span><br><span class="line">3. 注释：</span><br><span class="line">    单行注释 # 注释内容</span><br><span class="line">    多行注释 &#x2F;* 注释内容 *&#x2F;</span><br><span class="line">    单行注释 -- 注释内容 (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）)</span><br><span class="line">4. 模式通配符：</span><br><span class="line">    _ 任意单个字符</span><br><span class="line">    % 任意多个字符，甚至包括零字符</span><br><span class="line">    单引号需要进行转义 \&#39;</span><br><span class="line">5. CMD命令行内的语句结束符可以为 &quot;;&quot;, &quot;\G&quot;, &quot;\g&quot;，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结</span><br><span class="line"></span><br><span class="line">6. SQL对大小写不敏感 （关键字）</span><br><span class="line"></span><br><span class="line">7. 清除已有语句：\c</span><br></pre></td></tr></table></figure><h3 id="3、MySQL数据管理"><a href="#3、MySQL数据管理" class="headerlink" title="3、MySQL数据管理"></a>3、MySQL数据管理</h3><h4 id="3-1、外键"><a href="#3-1、外键" class="headerlink" title="3.1、外键"></a>3.1、外键</h4><blockquote><p>外键概念</p></blockquote><p>​    如果公共关键字在一个关系中是主关键字，那么这个公共关键字被称为另一个关系的外键。由此可见，外键表示了两个关系之间的相关联系。以另一个关系的外键作主关键字的表被称为<strong>主表</strong>，具有此外键的表被称为主表的<strong>从表</strong>。</p><p>​    在实际操作中，将一个表的值放入第二个表来表示关联，所使用的值是第一个表的主键值(在必要时可包<br>括复合主键值)。此时，第二个表中保存这些值的属性称为外键(<strong>foreign key</strong>)。</p><p><strong>外键作用</strong></p><p>​        保持数据<strong>一致性</strong>，<strong>完整性</strong>，主要目的是控制存储在外键表中的数据,<strong>约束</strong>。 使两张表形成关联，外键只能引用外表中的列的值或使用空值。</p><blockquote><p>创建外键</p></blockquote><p>建表是指定外键约束</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">-- 创建外键的方式一 : 创建子表同时创建外键</span><br><span class="line">-- 年级表 (id\年级名称)</span><br><span class="line">CREATE TABLE &#96;grade&#96; (</span><br><span class="line">    &#96;gradeid&#96; INT(10) NOT NULL AUTO_INCREMENT COMMENT &#39;年级ID&#39;,</span><br><span class="line">    &#96;gradename&#96; VARCHAR(50) NOT NULL COMMENT &#39;年级名称&#39;,</span><br><span class="line">    PRIMARY KEY (&#96;gradeid&#96;)</span><br><span class="line">) ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8</span><br><span class="line">-- 学生信息表 (学号,姓名,性别,年级,手机,地址,出生日期,邮箱,身份证号)</span><br><span class="line">CREATE TABLE &#96;student&#96; (</span><br><span class="line">    &#96;studentno&#96; INT(4) NOT NULL COMMENT &#39;学号&#39;,</span><br><span class="line">    &#96;studentname&#96; VARCHAR(20) NOT NULL DEFAULT &#39;匿名&#39; COMMENT &#39;姓名&#39;,</span><br><span class="line">    &#96;sex&#96; TINYINT(1) DEFAULT &#39;1&#39; COMMENT &#39;性别&#39;,</span><br><span class="line">    &#96;gradeid&#96; INT(10) DEFAULT NULL COMMENT &#39;年级&#39;,</span><br><span class="line">    &#96;phoneNum&#96; VARCHAR(50) NOT NULL COMMENT &#39;手机&#39;,</span><br><span class="line">    &#96;address&#96; VARCHAR(255) DEFAULT NULL COMMENT &#39;地址&#39;,</span><br><span class="line">    &#96;borndate&#96; DATETIME DEFAULT NULL COMMENT &#39;生日&#39;,</span><br><span class="line">    &#96;email&#96; VARCHAR(50) DEFAULT NULL COMMENT &#39;邮箱&#39;,</span><br><span class="line">    &#96;idCard&#96; VARCHAR(18) DEFAULT NULL COMMENT &#39;身份证号&#39;,</span><br><span class="line">    PRIMARY KEY (&#96;studentno&#96;),</span><br><span class="line">    KEY &#96;FK_gradeid&#96; (&#96;gradeid&#96;),</span><br><span class="line">    CONSTRAINT &#96;FK_gradeid&#96; FOREIGN KEY (&#96;gradeid&#96;) REFERENCES &#96;grade&#96;</span><br><span class="line">(&#96;gradeid&#96;)</span><br><span class="line">) ENGINE&#x3D;INNODB DEFAULT CHARSET&#x3D;utf8</span><br></pre></td></tr></table></figure><p>建表后修改</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- 创建外键方式二 : 创建子表完毕后,修改子表添加外键</span><br><span class="line">ALTER TABLE &#96;student&#96;</span><br><span class="line">ADD CONSTRAINT &#96;FK_gradeid&#96; FOREIGN KEY (&#96;gradeid&#96;) REFERENCES &#96;grade&#96;</span><br><span class="line">(&#96;gradeid&#96;);</span><br></pre></td></tr></table></figure><blockquote><p>删除外键</p></blockquote><p>操作：删除 grade 表，发现报错</p><p><img src= "/img/loading.gif" data-lazy-src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/20200913151012.png" alt="image-20200913151012238"></p><p><strong>注意</strong>：删除具有之外建关系的表时，要先删子表，后删主表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-- 删除外键</span><br><span class="line">ALTER TABLE student DROP FOREIGN KEY FK_gradeid;</span><br><span class="line">-- 发现执行完上面的,索引还在,所以还要删除索引</span><br><span class="line">-- 注:这个索引是建立外键的时候默认生成的</span><br><span class="line">ALTER TABLE student DROP INDEX FK_gradeid;</span><br></pre></td></tr></table></figure><h4 id="DML语言"><a href="#DML语言" class="headerlink" title="DML语言"></a>DML语言</h4><p><strong>数据库意义</strong>：数据存储、数据管理</p><p><strong>管理数据库数据方法：</strong></p><ul><li>通过SQLyog等管理工具管理数据库数据</li><li>通过<strong>DML语句</strong>管理数据库数据</li></ul><p><font color="FF0000"> DML语言 </font> :  数据操作语言</p><ul><li>用于操作数据库对象中包含的数据</li><li>包括<ul><li>INSERT（添加数据语句）</li><li>UPDATE (更新数据语句)</li><li>DELETE (删除数据语句)</li></ul></li></ul><h4 id="3-3、添加数据"><a href="#3-3、添加数据" class="headerlink" title="3.3、添加数据"></a>3.3、添加数据</h4><blockquote><p>INSERT命令</p></blockquote><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO 表名[(字段1,字段2,字段3,...)] VALUES(&#39;值1&#39;,&#39;值2&#39;,&#39;值3&#39;)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>字段或值之间用英文逗号隔开 .</li><li>‘ 字段1,字段2…’ 该部分可省略 , 但添加的值务必与表结构,数据列,顺序相对应,且数量一致 .</li><li>可同时插入多条数据 , values 后用英文逗号隔开 .</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- 使用语句如何增加语句?</span><br><span class="line">-- 语法 : INSERT INTO 表名[(字段1,字段2,字段3,...)] VALUES(&#39;值1&#39;,&#39;值2&#39;,&#39;值3&#39;)</span><br><span class="line">INSERT INTO grade(gradename) VALUES (&#39;大一&#39;);</span><br><span class="line"></span><br><span class="line">-- 主键自增,那能否省略呢?</span><br><span class="line">INSERT INTO grade VALUES (&#39;大二&#39;);</span><br><span class="line">-- 查询:INSERT INTO grade VALUE (&#39;大二&#39;)错误代码： 1136</span><br><span class="line">Column count doesn&#96;t match value count at row 1</span><br><span class="line"></span><br><span class="line">-- 结论:&#39;字段1,字段2...&#39;该部分可省略 , 但添加的值务必与表结构,数据列,顺序相对应,且数量一致.</span><br><span class="line"></span><br><span class="line">-- 一次插入多条数据</span><br><span class="line">INSERT INTO grade(gradename) VALUES (&#39;大三&#39;),(&#39;大四&#39;);</span><br></pre></td></tr></table></figure><h4 id="3-4、修改数据"><a href="#3-4、修改数据" class="headerlink" title="3.4、修改数据"></a>3.4、修改数据</h4><blockquote><p>update命令</p></blockquote><p><strong>语法：</strong></p><ul><li>字段或值之间用英文逗号隔开 .</li><li>‘ 字段1,字段2…’ 该部分可省略 , 但添加的值务必与表结构,数据列,顺序相对应,且数量一致 .</li><li>可同时插入多条数据 , values 后用英文逗号隔开 .</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-- 使用语句如何增加语句?</span><br><span class="line">-- 语法 : INSERT INTO 表名[(字段1,字段2,字段3,...)] VALUES(&#39;值1&#39;,&#39;值2&#39;,&#39;值3&#39;)</span><br><span class="line">INSERT INTO grade(gradename) VALUES (&#39;大一&#39;);</span><br><span class="line"></span><br><span class="line">-- 主键自增,那能否省略呢?</span><br><span class="line">INSERT INTO grade VALUES (&#39;大二&#39;);</span><br><span class="line"></span><br><span class="line">-- 查询:INSERT INTO grade VALUE (&#39;大二&#39;)错误代码： 1136</span><br><span class="line">Column count doesn&#96;t match value count at row 1</span><br><span class="line"></span><br><span class="line">-- 结论:&#39;字段1,字段2...&#39;该部分可省略 , 但添加的值务必与表结构,数据列,顺序相对应,且数量一致.</span><br><span class="line">-- 一次插入多条数据</span><br><span class="line">INSERT INTO grade(gradename) VALUES (&#39;大三&#39;),(&#39;大四&#39;);</span><br></pre></td></tr></table></figure><h4 id="3-4、修改数据-1"><a href="#3-4、修改数据-1" class="headerlink" title="3.4、修改数据"></a>3.4、修改数据</h4><blockquote><p>update命令</p></blockquote><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UPDATE 表名 SET column_name&#x3D;value [,column_name2&#x3D;value2,...] [WHERE condition];</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>column_name 为要更改的数据列</li><li>value 为修改后的数据 , 可以为变量 , 具体指 , 表达式或者嵌套的SELECT结果</li><li>condition 为筛选条件 , 如不指定则修改该表的所有列数据</li></ul><blockquote><p>where条件子句</p></blockquote><p>可以简单的理解为 : 有条件地从表中筛选数据</p><p><img src= "/img/loading.gif" data-lazy-src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/20200913152801.png" alt="image-20200913152801006"></p><p>测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-- 修改年级信息</span><br><span class="line">UPDATE grade SET gradename &#x3D; &#39;高中&#39; WHERE gradeid &#x3D; 1;</span><br></pre></td></tr></table></figure><h4 id="3-5、删除数据"><a href="#3-5、删除数据" class="headerlink" title="3.5、删除数据"></a>3.5、删除数据</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MySQL学习（持续更新）&quot;&gt;&lt;a href=&quot;#MySQL学习（持续更新）&quot; class=&quot;headerlink&quot; title=&quot;MySQL学习（持续更新）&quot;&gt;&lt;/a&gt;MySQL学习（持续更新）&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;作者：涂祎豪&lt;/p&gt;
&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>MongoDB学习</title>
    <link href="http://example.com/2020/11/08/MongoDB%E5%AD%A6%E4%B9%A0/"/>
    <id>http://example.com/2020/11/08/MongoDB%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-11-08T02:05:46.662Z</published>
    <updated>2020-09-27T08:09:42.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MongoDB学习"><a href="#MongoDB学习" class="headerlink" title="MongoDB学习"></a>MongoDB学习</h2><blockquote><p>作者：涂祎豪</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/20200927160938.png" alt="image-20200927160938217"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MongoDB学习&quot;&gt;&lt;a href=&quot;#MongoDB学习&quot; class=&quot;headerlink&quot; title=&quot;MongoDB学习&quot;&gt;&lt;/a&gt;MongoDB学习&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;作者：涂祎豪&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java面试整理(基础语法169道)</title>
    <link href="http://example.com/2020/11/08/Java%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"/>
    <id>http://example.com/2020/11/08/Java%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/</id>
    <published>2020-11-08T02:05:46.661Z</published>
    <updated>2020-09-13T03:31:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java面试整理-基础语法169道-——陆续更新"><a href="#Java面试整理-基础语法169道-——陆续更新" class="headerlink" title="Java面试整理(基础语法169道) ——陆续更新"></a>Java面试整理(基础语法169道) ——陆续更新</h3><blockquote><p>作者：涂祎豪</p></blockquote><h4 id="1-Java跨平台远离（字节码文件、虚拟机）"><a href="#1-Java跨平台远离（字节码文件、虚拟机）" class="headerlink" title="1.Java跨平台远离（字节码文件、虚拟机）"></a>1.Java跨平台远离（字节码文件、虚拟机）</h4><p>C/C++语言都是直接编译成针对特定平台机器码。如果要跨平台，需要使用相应的编译器重新编译。<br>Java源程序（.java）要先编译成与平台无关的字节码文件（.class），然后字节码文件再<br>解释成机器码运行。解释是通过Java虚拟机来执行的。<br>字节码文件不面相任何具体平台，只面相虚拟机。<br>Java虚拟机是可运行Java字节码文件的虚拟计算机。不同平台的虚拟机是不同的，但它们都提供了相同的接口。<br>Java语言具有一次编译，到处运行的特点。就是说编译后的.class可以跨平台运行，前提是该平台具有相应的Java虚拟机。但是性能比C/C++要低。<br>Java的跨平台远离决定了其性能没有C/C++高。</p><h4 id="Java跨平台编译原理"><a href="#Java跨平台编译原理" class="headerlink" title="Java跨平台编译原理"></a>Java跨平台编译原理</h4><p><img src= "/img/loading.gif" data-lazy-src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/20200910184606.png" alt="image-20200910184605185"></p><ol><li>一次编译，到处运行</li><li>编译器的作用：将源文件编译成class文件</li><li>虚拟机的作用：将字节码文件class文件解释成对应平台机器码并执行</li><li>Java可以跨所有的平台吗？只有提供并安装了相应的虚拟机，就可以跨该平台</li><li>虚拟机和解释器的关系：解释器是虚拟机的一个重要组成部分</li><li>Java语言的执行要经过编译和解释两个阶段</li></ol><hr><h4 id="C语言跨平台原理"><a href="#C语言跨平台原理" class="headerlink" title="C语言跨平台原理"></a>C语言跨平台原理</h4><p><img src= "/img/loading.gif" data-lazy-src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/20200910191530.png" alt="image-20200910191528618"></p><ol><li>多次编译，到处运行</li><li>C和Java那个平台速度快？ C语言是直接执行代码，Java是先将class文件爱你解释成机器码再执行</li><li>两种平台原理那种好？ 互联网上，平台各异，Java的一个编译结果可以放到所有平台上，这个是巨大优势</li></ol><hr><h4 id="2、Java的安全性"><a href="#2、Java的安全性" class="headerlink" title="2、Java的安全性"></a>2、Java的安全性</h4><h5 id="语言层次的安全性主要体现在："><a href="#语言层次的安全性主要体现在：" class="headerlink" title="语言层次的安全性主要体现在："></a>语言层次的安全性主要体现在：</h5><p>Java取消了强大又危险的指针，而代之以引用。由于指针可以进行移动运算，指针可以随便指向一个内存区域，而不管这个区域是否可用，这样做是十分危险的，因为原来之隔内存地址可能存储着和从要数据或者是其他程序所占用的，并且使用指针也容易数组越界。</p><h5 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h5><p>不需要程序员直接控制内存回收，由垃圾回收器在后台自动回收不再使用的内存。避免程序错误回收程序核心类库的内存，导致系统崩溃。</p><h5 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h5><p>Java异常机制主要依赖于try、catch、finally、throw、throws五个关键字。</p><h5 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h5><p>只有在满足强制类型转换规则的情况才能强转成功。</p><h5 id="底层的安全性可以从下面来说明："><a href="#底层的安全性可以从下面来说明：" class="headerlink" title="底层的安全性可以从下面来说明："></a>底层的安全性可以从下面来说明：</h5><p>Java在字节码的传输过程中使用了公开密钥加密机制（PKC）</p><h5 id="在运行环境提供了四级安全保障机制："><a href="#在运行环境提供了四级安全保障机制：" class="headerlink" title="在运行环境提供了四级安全保障机制："></a>在运行环境提供了四级安全保障机制：</h5><p>字节码校验器 - 类装载器 - 运行是内存布局 - 文件访问限制</p><hr><h4 id="3、Java三大版本"><a href="#3、Java三大版本" class="headerlink" title="3、Java三大版本"></a>3、Java三大版本</h4><p><strong>Java2平台包括标准版（J2SE）、企业版（J2EE）和微缩版（J2ME）三个版本：</strong><br>Standard Edition（标准版）J2SE包含那些构成Java语言核心的类。</p><p><em>比如：数据库连接、接口定义、输入/输出、网络编程</em></p><p>Enterprise Edition(企业版) J2EE 包含J2SE 中的类，并且还包含用于开发企业级应用的类。</p><p><em>比如servlet、JSP、XML、事务控制</em></p><p>Micro Edition(微缩版) J2ME 包含J2SE中一部分类，用于消费类电子产品的软件开发。</p><p><em>比如：呼机、智能卡、手机、PDA、机顶盒</em></p><p><strong>他们范围是：</strong></p><p>J2SE包含于J2EE中，J2ME包含了J2SE的核心类，但新添加了一些专有类应用场合，API的覆盖范围各不相同。</p><hr><h4 id="4、什么是JVM？什么是JDK？-什么是JRE？"><a href="#4、什么是JVM？什么是JDK？-什么是JRE？" class="headerlink" title="4、什么是JVM？什么是JDK？ 什么是JRE？"></a>4、什么是JVM？什么是JDK？ 什么是JRE？</h4><p><strong>JVM：</strong></p><p>​    VM是Java Virtual Machine（Java虚拟机）的缩写，它是整个Java实现跨平台的最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行，也就是说class并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。JVM是Java平台的基础，和实际的机器一样，它也有自己的指令集，并且在运行时操作不同的内存区域。 JVM通过抽象操作系统和CPU结构，提供了一种与平台无关的代码执行方法，即与特殊的实现方法、主机硬件、主机操作系统无关。JVM的主要工作是解释自己的指令集（即字节码）到CPU的指令集或对应的系统调用，保护用户免被恶意程序骚扰。 JVM对上层的Java源文件是不关心的，它关注的只是由源文件生成的类文件（.class文件）。</p><p><strong>JRE :</strong></p><p>​    JRE是java runtime environment（java运行环境）的缩写。光有JVM还不能让class文件执行，因为在解释class的时候JVM需要调用解释所需要的类库lib。在JDK的安装目录里你可以找到jre目录，里面有两个文件夹bin和lib,在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和lib和起来就称为jre。所以，在你写完java程序编译成.class之后，你可以把这个.class文件和jre一起打包发给朋友，这样你的朋友就可以运行你写程序了（jre里有运行.class的java.exe）。JRE是Sun公司发布的一个更大的系统，它里面就有一个JVM。JRE就与具体的CPU结构和操作系统有关，是运行Java程序必不可少的（除非用其他一些编译环境编译成.exe可执行文件……），JRE的地位就象一台PC机一样，我们写好的Win32应用程序需要操作系统帮我们运行，同样的，我们编写的Java程序也必须要JRE才能运行。</p><p><strong>JDK：</strong></p><p>​    JDK是java development kit（java开发工具包）的缩写。每个学java的人都会先在机器上装一个JDK，那 让我们看一下JDK的安装目录。在目录下面有六个文件夹、一个src类库源码压缩包、和其他几个声明文件。其中，真正在运行java时起作用的是以下四个文件夹：bin、include、lib、jre。现在我们可以看出这样一个关系，JDK包含JRE，而JRE包含JVM。</p><p><strong>bin：</strong>最主要的是编译器（javac.exe）</p><p><strong>include：</strong>java和JVM交互作用的头文件</p><p><strong>lib：</strong>类库</p><p><strong>jre：</strong>java运行环境</p><p>（注意：这里的bin、lib文件夹和jre里的bin、lib是不同的）</p><p>​    总的来说JDK是用于java程序的开发,而jre则是只能运行class而没有编译的功能。eclipse、idea等其他IDE有自己的编译器而不是用JDK bin目录中自带的，所以在安装时你会发现他们只要求你选jre路径就ok了。</p><p><strong>JDK,JRE,JVM三者关系概括如下：</strong></p><p>​    jdk是JAVA程序开发时用的开发工具包，其内部也有JRE运行环境JRE。JRE是JAVA程序运行时需要的运行环境，就是说如果你光是运行JAVA程序而不是去搞开发的话，只安装JRE就能运行已经存在的JAVA程序了。JDk、JRE内部都包含JAVA虚拟机JVM，JAVA虚拟机内部包含许多应用程序的类的解释器和类加载器等等。</p><hr><h4 id="Java三种注释类型"><a href="#Java三种注释类型" class="headerlink" title="Java三种注释类型"></a>Java三种注释类型</h4><p>共有单行注释、多行注释、文档注释3种注释类型。</p><h5 id="单行注释，采用“-”方式-只能注释一行代码。如："><a href="#单行注释，采用“-”方式-只能注释一行代码。如：" class="headerlink" title="单行注释，采用“//”方式.只能注释一行代码。如："></a>单行注释，采用“//”方式.只能注释一行代码。如：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//成员变量</span></span><br></pre></td></tr></table></figure><h5 id="多行注释，采用“-…-”方式，可注释多行代码，其中不允许出现嵌套。如："><a href="#多行注释，采用“-…-”方式，可注释多行代码，其中不允许出现嵌套。如：" class="headerlink" title="多行注释，采用“/…/”方式，可注释多行代码，其中不允许出现嵌套。如："></a>多行注释，采用“/<em>…</em>/”方式，可注释多行代码，其中不允许出现嵌套。如：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">System.out.println(&quot;a&quot;);</span></span><br><span class="line"><span class="comment">System.out.println(&quot;b&quot;);</span></span><br><span class="line"><span class="comment">System.out.println(&quot;c&quot;);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="文档注释，采用“-…-”方式，如："><a href="#文档注释，采用“-…-”方式，如：" class="headerlink" title="文档注释，采用“/*…/”方式，如："></a>文档注释，采用“/*<em>…</em>/”方式，如：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> 涂祎豪</span></span><br><span class="line"><span class="comment">* <span class="doctag">@descripted</span> QQ:2914021718</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><hr><h4 id="6-八种基本数据类型及其字节数"><a href="#6-八种基本数据类型及其字节数" class="headerlink" title="6. 八种基本数据类型及其字节数"></a>6. 八种基本数据类型及其字节数</h4><p><img src= "/img/loading.gif" data-lazy-src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/20200910165100.png" alt="image-20200910165058627"></p><hr><h4 id="7-i-和-i的异同之处"><a href="#7-i-和-i的异同之处" class="headerlink" title="7. i++和++i的异同之处"></a>7. i++和++i的异同之处</h4><h5 id="共同点："><a href="#共同点：" class="headerlink" title="共同点："></a>共同点：</h5><ol><li>i++和++i都是变量自增1，都等价于i=i+1</li><li>如果i++,++i是一条单独的语句，两者没有任何区别</li><li>i++和++i的使用仅仅针对变量。 5++和++5会报错，因为5不是变量。</li></ol><h5 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h5><p>如果i++,++i不是一条单独的语句，他们就有区别</p><p>i++ ：先运算后增1。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> y=x++;System.out.println(<span class="string">&quot;x=&quot;</span>+x+<span class="string">&quot;, y=&quot;</span>+y);<span class="comment">//以上代码运行后输出结果为：x=6, y=5</span></span><br></pre></td></tr></table></figure><p>++i ： 先增1后运算。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> y=++x;</span><br><span class="line">System.out.println(<span class="string">&quot;x=&quot;</span>+x+<span class="string">&quot;, y=&quot;</span>+y);<span class="comment">//以上代码运行后输出结果为：x=6, y=6</span></span><br></pre></td></tr></table></figure><hr><h4 id="8-amp-和-amp-amp-和-的区别和联系"><a href="#8-amp-和-amp-amp-和-的区别和联系" class="headerlink" title="8. &amp;和&amp;&amp; , |和|| 的区别和联系"></a>8. &amp;和&amp;&amp; , |和|| 的区别和联系</h4><p><strong>&amp;和&amp;&amp;的联系(共同点)：</strong></p><p>&amp;和&amp;&amp;都可以用作逻辑与运算符，但是要看使用时的具体条件来决定。</p><p><strong>操作数1&amp;操作数2，操作数1&amp;&amp;操作数2，</strong></p><p><strong>表达式1&amp;表达式2，表达式1&amp;&amp;表达式2，</strong></p><p><strong>情况1：</strong>当上述的操作数是boolean类型变量时，&amp;和&amp;&amp;都可以用作逻辑与运算符。</p><p><strong>情况2：</strong>当上述的表达式结果是boolean类型变量时，&amp;和&amp;&amp;都可以用作逻辑与运算符。表示逻辑与(and)，当运算符两边的表达式的结果或操作数都为true时，整个运算结果才为true，否则，只要有一方为false，结果都为false。</p><p><strong>&amp;和&amp;&amp;的区别：</strong></p><ol><li><p>&amp; 称为逻辑与运算符，&amp;&amp; 称为短路与运算符，也可叫逻辑与运算符。</p><p> 对于&amp;：无论任何情况，&amp;两边的操作数或表达式都会参与计算。</p><p> 对于&amp;&amp;：当&amp;&amp;左边的操作数为false或左边表达式结果为false时，&amp;&amp;右边的操作数或表达式将不参与计算，此时最终结果都为false。</p><p> 综上所述，如果逻辑与运算的第一个操作数是false或第一个表达式的结果为false时，对于第二个操作数或表达式是否进行运算，对最终的结果没有影响，结果肯定是false。推介平时多使用&amp;&amp;，因为它效率更高些。</p></li><li><p>&amp;还可以用作位运算符。当&amp;两边操作数或两边表达式的结果不是boolean类型时，&amp;用于按位与运算符的操作。</p><p>|和||的区别和联系与&amp;和&amp;&amp;的区别和联系类似</p></li></ol><hr><h4 id="9-用最有效率的方法算出2乘以8等于多少"><a href="#9-用最有效率的方法算出2乘以8等于多少" class="headerlink" title="9. 用最有效率的方法算出2乘以8等于多少"></a>9. 用最有效率的方法算出2乘以8等于多少</h4><p>使用位运算来实现效率最高。位运算符是对操作数以二进制比特位为单位进行操作和运算，操作数和结果都是整型数。</p><p>对于位运算符“&lt;&lt;”, 是将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8只要将其左移3位即可，位运算cpu直接支持的，效率最高。所以，2乘以8等于几的最效率的方法是2 &lt;&lt; 3。</p><hr><h4 id="10-基本数据类型的类型转换规则"><a href="#10-基本数据类型的类型转换规则" class="headerlink" title="10. 基本数据类型的类型转换规则"></a>10. 基本数据类型的类型转换规则</h4><p>基本类型转换分为自动转换和强制转换。</p><p><strong>自动转换规则：</strong></p><p>容量小的数据类型 可以自动转换成容量大的数据类型，也可以说低级自动向高级转换。这儿的容量指的不是字节数，而是指类型表述的范围。</p><p><img src= "/img/loading.gif" data-lazy-src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/20200910191721.png" alt="image-20200910191719252"></p><p><strong>强制转换规则：</strong></p><p>高级变为低级需要强制转换。</p><p><strong>如何转换：</strong></p><ol><li>赋值运算符“=”右边的转换，先自动转换成表达式中级别最高的数据类型，再进行运算。</li><li>赋值运算符 “=” 两侧的转换，若左边级别&gt;右边级别，会自动转换；若左边级别 == 右边级别，不用转换；若左边级别 &lt; 右边级别，需强制转换。</li><li>可以将整型常量直接赋值给byte, short, char等类型变量，而不需要进行强制类型转换，前提是不超出其表述范围，否则必须进行强制转换。</li></ol><hr><h4 id="11-if和switch的异同之处"><a href="#11-if和switch的异同之处" class="headerlink" title="11. if和switch的异同之处"></a>11. if和switch的异同之处</h4><p><strong>相同之处</strong>：</p><p>都是分支语句，多超过一种的情况进行判断处理。</p><p><strong>不同之处：</strong></p><p>switch更适合用于多分支情况，就是有很多种情况需要判断处理，判断条件类型单一，只有一个入口，在分支执行完后（如果没有break跳出），不加判断地执行下去; 而if—elseif—else多分枝主要适用于分支较少的分支结构，判断类型不是单一，只要一个分支被执行后，后边的分支不再执行。</p><p>switch为等值判断（不允许比如&gt;= &lt;=），而if为等值和区间都可以，if的使用范围大。</p><hr><h4 id="12-while和do-while循环的区别"><a href="#12-while和do-while循环的区别" class="headerlink" title="12. while和do-while循环的区别"></a>12. while和do-while循环的区别</h4><p>while先判断后执行，第一次判断为false , 循环体一次都不执行。<br>do while先执行 后判断，最少执行1次。<br>如果while循环第一次判断为true, 则两种循环没有区别。</p><hr><h4 id="13-break和continue的作用"><a href="#13-break和continue的作用" class="headerlink" title="13. break和continue的作用"></a>13. break和continue的作用</h4><p><strong>break:</strong> 结束当前循环并退出当前循环体。break还可以退出switch语句<br><strong>continue:</strong> 循环体中后续的语句不执行，但是循环没有结束，继续进行循环条件的判断（for循环还会i++）。continue只是结束本次循环。</p><hr><h4 id="14-请使用递归算法计算n！"><a href="#14-请使用递归算法计算n！" class="headerlink" title="14. 请使用递归算法计算n！"></a>14. 请使用递归算法计算n！</h4><p>一个正整数的阶乘（factorial）是所有小于及等于该数的正整数的积，并且0的阶乘为1。 自然数n的阶乘写作n!。1808年，基斯顿·卡曼引进这个表示法。 亦即n!=1×2×3×…×n。阶乘亦可以递归方式定义：0!=1，n!=(n-1)!×n。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* n阶乘</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recursion</span> </span>&#123;</span><br><span class="line"><span class="comment">//阶乘算法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (num==<span class="number">0</span> || num== <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">return</span> num*factorial(num-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Recursion recursion = <span class="keyword">new</span> Recursion();</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> factorial = recursion.factorial(n);</span><br><span class="line">System.out.println(factorial);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="15-递归的定义和优缺点"><a href="#15-递归的定义和优缺点" class="headerlink" title="15. 递归的定义和优缺点"></a>15. 递归的定义和优缺点</h4><p>​    递归算法是一种直接或者间接地调用自身算法的过程。在计算机编写程序中，递归算法对解决一大类问题是十分有效的，它往往使算法的描述简洁而且易于理解。</p><p><strong>递归算法解决问题的特点：</strong></p><ol><li>递归就是在过程或函数里调用自身。</li><li>在使用递归策略时，必须有一个明确的递归结束条件，称为递归出口。</li><li>递归算法解题通常显得很简洁，但运行效率较低。所以一般不提倡用递归算法设计程序。</li><li>在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成栈溢出等。所以一般不提倡用递归算法设计程序。</li></ol><hr><h4 id="16-数组的特征"><a href="#16-数组的特征" class="headerlink" title="16. 数组的特征"></a>16. 数组的特征</h4><p>数组是（相同类型数据）的（有序）（集合）</p><p>数组会在内存中开辟一块连续的空间，每个空间相当于之前的一个变量，称为数组的元素element元素的表示 数组名[下标或者索引] <code>scores[7] scores[0] scores[9]</code></p><p>索引从0开始</p><p>每个数组元素有默认值<code>double 0.0; boolean false; int 0</code></p><p>数组元素有序的，不是大小顺序，是索引的顺序</p><p>数组中可以存储基本数据类型，可以存储引用数据类型；但是对于一个数组而言，数组的类型是固定的，只能是一个length:数组的长度</p><p>数组的长度是固定的，一经定义，不能再发生变化（数组的扩容）</p><hr><h4 id="17-请写出冒泡排序代码"><a href="#17-请写出冒泡排序代码" class="headerlink" title="17. 请写出冒泡排序代码"></a>17. 请写出冒泡排序代码</h4><p>冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。</p><p>它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。</p><p>这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。</p><p>冒泡排序算法的原理如下：</p><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 冒泡排序</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bubble</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 外层循环，它决定一共走几趟 //-1为了防止溢出</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>; <span class="comment">//通过符号位可以减少无谓的比较，如果已经有序了，就退出循环</span></span><br><span class="line"><span class="comment">//内层循环，它决定每趟走一次</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line"><span class="comment">//如果后一个大于前一个,则换位</span></span><br><span class="line"><span class="keyword">if</span> (array[j + <span class="number">1</span>] &gt; array[j]) &#123;</span><br><span class="line">temp = array[j];</span><br><span class="line">array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">array[j + <span class="number">1</span>] = temp;</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Bubble bubble = <span class="keyword">new</span> Bubble();</span><br><span class="line">    <span class="keyword">int</span>[] array = &#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] sort = bubble.sort(array);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num:sort)&#123;</span><br><span class="line">System.out.print(num+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="18-请写出选择排序的代码"><a href="#18-请写出选择排序的代码" class="headerlink" title="18. 请写出选择排序的代码"></a>18. 请写出选择排序的代码</h4><p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法。</p><table><thead><tr><th>排序方法</th><th>最好时间</th><th>平均时间</th><th>最坏时间</th><th>辅助空间</th><th>稳定性</th></tr></thead><tbody><tr><td>直接插入</td><td>O(n)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>稳定</td></tr><tr><td>二分插入</td><td>O(n)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>稳定</td></tr><tr><td>希  尔</td><td></td><td>O(n^1.25)</td><td></td><td>O(1)</td><td>不稳定</td></tr><tr><td>冒  泡</td><td>O(n)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>稳定</td></tr><tr><td>快  速</td><td>O(nlgn)</td><td>O(nlgn)</td><td>O(n^2)</td><td>O(lgn)</td><td>不稳定</td></tr><tr><td>直接选择</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>堆</td><td>O(nlgn)</td><td>O(nlgn)</td><td>O(nlgn)</td><td></td><td>不稳定</td></tr><tr><td>归  并</td><td>O(nlgn)</td><td>O(nlgn)</td><td>O(nlgn)</td><td>O(n)</td><td>稳定</td></tr><tr><td>基   数</td><td>O(d(rd+n))</td><td>O(d(rd+n))</td><td>O(d(rd+n))</td><td>O(rd+n)</td><td>稳定</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 选择排序</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSort</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span> arr[]) &#123;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="comment">// 认为目前的数就是最小的, 记录最小数的下标</span></span><br><span class="line"><span class="keyword">int</span> minIndex = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line"><span class="comment">// 修改最小值的下标</span></span><br><span class="line">minIndex = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当退出for就找到这次的最小值,就需要交换位置了</span></span><br><span class="line"><span class="keyword">if</span> (i != minIndex) &#123;</span><br><span class="line">    <span class="comment">//交换当前值和找到的最小值的位置</span></span><br><span class="line">temp = arr[i];</span><br><span class="line">arr[i] = arr[minIndex];</span><br><span class="line">arr[minIndex] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SelectSort selectSort = <span class="keyword">new</span> SelectSort();</span><br><span class="line"><span class="keyword">int</span>[] array = &#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] sort = selectSort.sort(array);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num:sort)&#123;</span><br><span class="line">System.out.print(num+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="19-请写出插入排序的代码"><a href="#19-请写出插入排序的代码" class="headerlink" title="19. 请写出插入排序的代码"></a>19. 请写出插入排序的代码</h4><p>​    有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序方法——插入排序法</p><p>​    插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。</p><p>​    插入排序的基本思想是：每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。</p><p>​    包括：直接插入排序，二分插入排序（又称折半插入排序），链表插入排序，希尔排序（又称缩小增量排序）。属于稳定排序的一种（通俗地讲，就是两个相等的数不会交换位置） 。</p><p>​    一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下： ⒈ 从第一个元素开始，该元素可以认为已经被排序 ⒉ 取出下一个元素，在已经排序的元素序列中从后向前扫描 ⒊ 如果该元素（已排序）大于新元素，将该元素移到下一位置 ⒋ 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 ⒌ 将新元素插入到下一位置中 ⒍重复步骤2~5</p><p>​    如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的数目。该算法可以认为是插入排序的一个变种，称为二分查找排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 插入排序</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[]arr)&#123;</span><br><span class="line"><span class="comment">//如果传入的数组为空或者只有一个值,就直接返回</span></span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不为空则进循环判断</span></span><br><span class="line"><span class="comment">//外层循环控制总数量</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line"><span class="comment">//内层循环依次减少并提出结果</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line"><span class="comment">//如果当前数字小于前一个,则交换,否则不变</span></span><br><span class="line"><span class="keyword">if</span>(arr[j]&lt;arr[j-<span class="number">1</span>])&#123;</span><br><span class="line"><span class="keyword">int</span> temp=arr[j];</span><br><span class="line">arr[j]=arr[j-<span class="number">1</span>];</span><br><span class="line">arr[j-<span class="number">1</span>]=temp;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">InsertSort insertSort = <span class="keyword">new</span> InsertSort();</span><br><span class="line"><span class="keyword">int</span>[] array = &#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] sort = insertSort.sort(array);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> num:sort)&#123;</span><br><span class="line">System.out.print(num+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="20-可变参数的作用和特点"><a href="#20-可变参数的作用和特点" class="headerlink" title="20. 可变参数的作用和特点"></a>20. 可变参数的作用和特点</h4><p>详解 : <a href="https://www.cnblogs.com/uptownBoy/articles/1698335.html">https://www.cnblogs.com/uptownBoy/articles/1698335.html</a></p><p><strong>总结1：</strong>可变参数</p><ol><li>可变参数的形式 …</li><li>可变参数只能是方法的形参</li><li>可变参数对应的实参可以0,1,2…..n个，也可以是一个数组</li><li>在可变参数的方法中，将可变参数当做数组来处理</li><li>可变参数最多有一个，只能是最后一个</li><li>可变参数好处：方便 简单 减少重载方法的数量</li><li>如果定义了可变参数的方法，不允许同时定义相同类型数组参数的方法</li></ol><p><strong>总结2：</strong> 数组做形参和可变参数做形参联系和区别</p><p><strong>联系：</strong></p><ol><li>实参都可以是数组；</li><li>方法体中，可变参数本质就是当做数组来处理</li></ol><p><strong>区别：</strong></p><ol><li>个数不同 可变参数只能有一个数组参数可以多个</li><li>位置不同 可变参数只能是最后一个 数组参数位置任意</li><li>实参不同 可变参数实参可以0,1,2…..个，也可以是一个数组，数组的实参只能是数组</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">sum += values[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="21-类和对象的关系"><a href="#21-类和对象的关系" class="headerlink" title="21. 类和对象的关系"></a>21. 类和对象的关系</h4><p>​    类是对象的抽象，而对象是类的具体实例。 类是抽象的，不占用内存，而对象是具体的，占用存储空间。 类是用于创建对象的蓝图，类就是一个带方法和变量的特定类型</p><p>​    类和对象好比图纸和实物的关系，模具和铸件的关系。</p><p>​    比如人类就是一个概念，人类具有身高，体重等属性。人类可以做吃饭、说话等方法。</p><p>​    小明就是一个具体的人，也就是实例，他的属性是具体的身高200cm，体重180kg，他做的方法是具体的吃了一碗白米饭，说了“12345”这样一句话。</p><p>​    还可以有小红,小蓝等具体的人即对象,但他们都是人类的实例,即类。</p><hr><h4 id="22-面向过程和面向对象的区别"><a href="#22-面向过程和面向对象的区别" class="headerlink" title="22. 面向过程和面向对象的区别"></a>22. 面向过程和面向对象的区别</h4><p>​    两者都是软件开发思想，先有面向过程，后有面向对象。在大型项目中，针对面向过程的不足推出了面向对象开发思想。</p><p><img src= "/img/loading.gif" data-lazy-src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/20200910205016.png" alt="image-20200910205012487"></p><p><strong>区别:</strong></p><p><strong>编程思路不同：</strong> 面向过程以实现功能的函数开发为主，而面向对象要首先抽象出类、属性及其方法，然后通过实例化类、执行方法来完成功能。</p><p><strong>封装性：</strong>都具有封装性，但是面向过程是封装的是功能，而面向对象封装的是数据和功能。</p><p>面向对象具有继承性和多态性，而面向过程没有继承性和多态性，所以面向对象优势是明显。</p><p><strong>方法重载和方法重写（覆盖）的区别：</strong></p><table><thead><tr><th></th><th>英文</th><th>位置不同</th><th>作用不同</th></tr></thead><tbody><tr><td>重载</td><td>overlord</td><td>同一个类中</td><td>在一个类里面为一种行为提供过重实现方式并提高可读性</td></tr><tr><td>重写</td><td>override</td><td>子类和父类间</td><td>父类方法无法满足子类的要求，子类通过方法重写满足要求</td></tr></tbody></table><table><thead><tr><th></th><th>修饰符</th><th>返回值</th><th>方法名</th><th>参数</th><th>抛出异常</th></tr></thead><tbody><tr><td>重载</td><td>无关</td><td>无关</td><td>相同</td><td>不同</td><td>无关</td></tr><tr><td>重写</td><td>大于等于</td><td>小于等于</td><td>相同</td><td>相同</td><td>小于等于</td></tr></tbody></table><hr><h4 id="23-this和super关键字的作用"><a href="#23-this和super关键字的作用" class="headerlink" title="23. this和super关键字的作用"></a>23. this和super关键字的作用</h4><p>​    this是对象内部指代自身的引用,同时也是解决成员变量和局部变量同名问题；this可以调用成员变量，不能调用局部变量；this也可以调用成员方法，但是在普通方法中可以省略this，在构造方法中不允许省略，必须是构造方法的第一条语句。而且在静态方法当中不允许出现this关键字。</p><p>​    super代表对当前对象的直接父类对象的引用，super可以调用直接父类的成员变量（注意权限修饰符的影响，不如不能访问private成员）</p><p>​    super可以调用直接父类的成员方法（注意权限修饰符的影响，比如不能访问private成员）；super可以调用直接父类的构造方法，只限构造方法中使用，且必须是第一条语句。</p><hr><h4 id="24-static关键字的作用"><a href="#24-static关键字的作用" class="headerlink" title="24. static关键字的作用"></a>24. static关键字的作用</h4><p>​    static可以修饰变量、方法、代码块和内部类</p><p>​    static属性属于这个类所有，即由该类创建的所有对象共享同一个static属性。可以对象创建后通过对象名.属性名和类名.属性名两种方式来访问。也可以在没有创建任何对象之前通过类名.属性名的方式来访问。</p><p>​    .static变量和非static变量的区别(都是成员变量，不是局部变量)</p><h5 id="1-在内存中份数不同"><a href="#1-在内存中份数不同" class="headerlink" title="1. 在内存中份数不同"></a>1. 在内存中份数不同</h5><p>不管有多少个对象，static变量只有1份。对于每个对象，实例变量都会有单独的一份</p><p>static变量是属于整个类，也称为类变量。而非静态变量是属于对象的，也称为实例变量</p><h5 id="2-在内存中存放的位置不同"><a href="#2-在内存中存放的位置不同" class="headerlink" title="2.在内存中存放的位置不同"></a>2.在内存中存放的位置不同</h5><p>静态变量存在方法区中， 实例变量存在堆内存中</p><p><img src= "/img/loading.gif" data-lazy-src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/20200912211707.png" alt="image-20200912211705895"></p><h5 id="3-访问的方式不同"><a href="#3-访问的方式不同" class="headerlink" title="3. 访问的方式不同"></a>3. 访问的方式不同</h5><p><strong>实例变量：</strong>对象名.变量名 <em>stu1.name=”小明明”</em></p><p><strong>静态变量：</strong>对象名.变量名 <em>stu1.schoolName=”西二旗小学”;</em> 不推荐如此使用</p><p>*类名.变量名 Student.schoolName=”东三旗小学”;*推荐使用</p><h5 id="4-在内存中分配空间的时间不同"><a href="#4-在内存中分配空间的时间不同" class="headerlink" title="4. 在内存中分配空间的时间不同"></a>4. 在内存中分配空间的时间不同</h5><p><strong>实例变量：</strong>创建对象的时候才分配了空间。静态变量：第一次使用类的时候</p><p><em>Student.schoolName=”东三旗小学”;<em>或者</em>Student stu1 = new Student(“小明”,”男”,20,98);</em></p><p>static方法也可以通过对象名.方法名和类名.方法名两种方式来访问</p><p>static代码块。当类被第一次使用时（可能是调用static属性和方法，或者创建其对象）执行静态代码块，且只被执行一次，主要作用是实现static属性的初始化。</p><p><strong>static内部类：</strong>属于整个外部类，而不是属于外部类的每个对象。不能访问外部类的非静态成员（变量或者方法），可以访问外部类的静态成员</p><hr><h4 id="25-final和abstract关键字的作用"><a href="#25-final和abstract关键字的作用" class="headerlink" title="25. final和abstract关键字的作用"></a>25. final和abstract关键字的作用</h4><p>final和abstract是功能相反的两个关键字，可以对比记忆</p><p>abstract可以用来修饰类和方法，不能用来修饰属性和构造方法；使用abstract修饰的类是抽象类，需要被继承，使用abstract修饰的方法是抽象方法，需要子类被重写。</p><p>final可以用来修饰类、方法和属性，不能修饰构造方法。使用final修饰的类不能被继承，使用final修饰的方法不能被重写，使用final修饰的变量的值不能被修改，所以就成了常量。</p><p>特别注意：final修饰基本类型变量，其值不能改变，由原来的变量变为常量；但是final修饰引用类型变量，栈内存中的引用不能改变，但是所指向的堆内存中的对象的属性值仍旧可以改变。例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">final</span> People people = <span class="keyword">new</span> People(<span class="string">&quot;狂神&quot;</span>);</span><br><span class="line">dog.name = <span class="string">&quot;malloc&quot;</span>;<span class="comment">//正确</span></span><br><span class="line">people = <span class="keyword">new</span> People(<span class="string">&quot;malloc&quot;</span>);<span class="comment">//错误</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Java面试整理-基础语法169道-——陆续更新&quot;&gt;&lt;a href=&quot;#Java面试整理-基础语法169道-——陆续更新&quot; class=&quot;headerlink&quot; title=&quot;Java面试整理(基础语法169道) ——陆续更新&quot;&gt;&lt;/a&gt;Java面试整理(基础语法</summary>
      
    
    
    
    
  </entry>
  
</feed>
