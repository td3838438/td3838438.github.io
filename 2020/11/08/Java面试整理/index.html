<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java面试整理(基础语法169道) | 涂祎豪の博客</title><meta name="description" content="Java面试整理(基础语法169道) ——陆续更新 作者：涂祎豪  1.Java跨平台远离（字节码文件、虚拟机）C&#x2F;C++语言都是直接编译成针对特定平台机器码。如果要跨平台，需要使用相应的编译器重新编译。Java源程序（.java）要先编译成与平台无关的字节码文件（.class），然后字节码文件再解释成机器码运行。解释是通过Java虚拟机来执行的。字节码文件不面相任何具体平台，只面相虚拟机。Jav"><meta name="author" content="涂祎豪"><meta name="copyright" content="涂祎豪"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2020/11/08/Java%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Java面试整理(基础语法169道)"><meta property="og:url" content="http://example.com/2020/11/08/Java%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/"><meta property="og:site_name" content="涂祎豪の博客"><meta property="og:description" content="Java面试整理(基础语法169道) ——陆续更新 作者：涂祎豪  1.Java跨平台远离（字节码文件、虚拟机）C&#x2F;C++语言都是直接编译成针对特定平台机器码。如果要跨平台，需要使用相应的编译器重新编译。Java源程序（.java）要先编译成与平台无关的字节码文件（.class），然后字节码文件再解释成机器码运行。解释是通过Java虚拟机来执行的。字节码文件不面相任何具体平台，只面相虚拟机。Jav"><meta property="og:image" content="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg"><meta property="article:published_time" content="2020-11-08T02:05:46.661Z"><meta property="article:modified_time" content="2020-09-13T03:31:08.000Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false    
}</script><script id="config_change">var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true,
  postUpdate: '2020-09-13 11:31:08'
}</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img {
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 5.2.0"><link rel="alternate" href="/atom.xml" title="涂祎豪の博客" type="application/atom+xml">
</head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" data-lazy-src="/img/avatar.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">60</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 標籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 清單</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音樂</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 電影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div id="body-wrap"><div id="web_bg" data-type="photo"></div><div id="sidebar"><i class="fas fa-arrow-right on" id="toggle-sidebar"></i><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95169%E9%81%93-%E2%80%94%E2%80%94%E9%99%86%E7%BB%AD%E6%9B%B4%E6%96%B0"><span class="toc-number">1.</span> <span class="toc-text">Java面试整理(基础语法169道) ——陆续更新</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Java%E8%B7%A8%E5%B9%B3%E5%8F%B0%E8%BF%9C%E7%A6%BB%EF%BC%88%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6%E3%80%81%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%89"><span class="toc-number">1.1.</span> <span class="toc-text">1.Java跨平台远离（字节码文件、虚拟机）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E8%B7%A8%E5%B9%B3%E5%8F%B0%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">Java跨平台编译原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C%E8%AF%AD%E8%A8%80%E8%B7%A8%E5%B9%B3%E5%8F%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">C语言跨平台原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2%E3%80%81Java%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">1.4.</span> <span class="toc-text">2、Java的安全性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AF%AD%E8%A8%80%E5%B1%82%E6%AC%A1%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%BB%E8%A6%81%E4%BD%93%E7%8E%B0%E5%9C%A8%EF%BC%9A"><span class="toc-number">1.4.1.</span> <span class="toc-text">语言层次的安全性主要体现在：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.2.</span> <span class="toc-text">垃圾回收机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.3.</span> <span class="toc-text">异常处理机制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.4.4.</span> <span class="toc-text">强制类型转换</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E5%8F%AF%E4%BB%A5%E4%BB%8E%E4%B8%8B%E9%9D%A2%E6%9D%A5%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">1.4.5.</span> <span class="toc-text">底层的安全性可以从下面来说明：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83%E6%8F%90%E4%BE%9B%E4%BA%86%E5%9B%9B%E7%BA%A7%E5%AE%89%E5%85%A8%E4%BF%9D%E9%9A%9C%E6%9C%BA%E5%88%B6%EF%BC%9A"><span class="toc-number">1.4.6.</span> <span class="toc-text">在运行环境提供了四级安全保障机制：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3%E3%80%81Java%E4%B8%89%E5%A4%A7%E7%89%88%E6%9C%AC"><span class="toc-number">1.5.</span> <span class="toc-text">3、Java三大版本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AFJVM%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AFJDK%EF%BC%9F-%E4%BB%80%E4%B9%88%E6%98%AFJRE%EF%BC%9F"><span class="toc-number">1.6.</span> <span class="toc-text">4、什么是JVM？什么是JDK？ 什么是JRE？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java%E4%B8%89%E7%A7%8D%E6%B3%A8%E9%87%8A%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.7.</span> <span class="toc-text">Java三种注释类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E8%A1%8C%E6%B3%A8%E9%87%8A%EF%BC%8C%E9%87%87%E7%94%A8%E2%80%9C-%E2%80%9D%E6%96%B9%E5%BC%8F-%E5%8F%AA%E8%83%BD%E6%B3%A8%E9%87%8A%E4%B8%80%E8%A1%8C%E4%BB%A3%E7%A0%81%E3%80%82%E5%A6%82%EF%BC%9A"><span class="toc-number">1.7.1.</span> <span class="toc-text">单行注释，采用“&#x2F;&#x2F;”方式.只能注释一行代码。如：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A%EF%BC%8C%E9%87%87%E7%94%A8%E2%80%9C-%E2%80%A6-%E2%80%9D%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%8F%AF%E6%B3%A8%E9%87%8A%E5%A4%9A%E8%A1%8C%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%85%B6%E4%B8%AD%E4%B8%8D%E5%85%81%E8%AE%B8%E5%87%BA%E7%8E%B0%E5%B5%8C%E5%A5%97%E3%80%82%E5%A6%82%EF%BC%9A"><span class="toc-number">1.7.2.</span> <span class="toc-text">多行注释，采用“&#x2F;…&#x2F;”方式，可注释多行代码，其中不允许出现嵌套。如：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%87%E6%A1%A3%E6%B3%A8%E9%87%8A%EF%BC%8C%E9%87%87%E7%94%A8%E2%80%9C-%E2%80%A6-%E2%80%9D%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%A6%82%EF%BC%9A"><span class="toc-number">1.7.3.</span> <span class="toc-text">文档注释，采用“&#x2F;*…&#x2F;”方式，如：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%85%AB%E7%A7%8D%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%85%B6%E5%AD%97%E8%8A%82%E6%95%B0"><span class="toc-number">1.8.</span> <span class="toc-text">6. 八种基本数据类型及其字节数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-i-%E5%92%8C-i%E7%9A%84%E5%BC%82%E5%90%8C%E4%B9%8B%E5%A4%84"><span class="toc-number">1.9.</span> <span class="toc-text">7. i++和++i的异同之处</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B1%E5%90%8C%E7%82%B9%EF%BC%9A"><span class="toc-number">1.9.1.</span> <span class="toc-text">共同点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E7%82%B9%EF%BC%9A"><span class="toc-number">1.9.2.</span> <span class="toc-text">不同点：</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-amp-%E5%92%8C-amp-amp-%E5%92%8C-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="toc-number">1.10.</span> <span class="toc-text">8. &amp;和&amp;&amp; , |和|| 的区别和联系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-%E7%94%A8%E6%9C%80%E6%9C%89%E6%95%88%E7%8E%87%E7%9A%84%E6%96%B9%E6%B3%95%E7%AE%97%E5%87%BA2%E4%B9%98%E4%BB%A58%E7%AD%89%E4%BA%8E%E5%A4%9A%E5%B0%91"><span class="toc-number">1.11.</span> <span class="toc-text">9. 用最有效率的方法算出2乘以8等于多少</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%A7%84%E5%88%99"><span class="toc-number">1.12.</span> <span class="toc-text">10. 基本数据类型的类型转换规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-if%E5%92%8Cswitch%E7%9A%84%E5%BC%82%E5%90%8C%E4%B9%8B%E5%A4%84"><span class="toc-number">1.13.</span> <span class="toc-text">11. if和switch的异同之处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-while%E5%92%8Cdo-while%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.14.</span> <span class="toc-text">12. while和do-while循环的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-break%E5%92%8Ccontinue%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.15.</span> <span class="toc-text">13. break和continue的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-%E8%AF%B7%E4%BD%BF%E7%94%A8%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E8%AE%A1%E7%AE%97n%EF%BC%81"><span class="toc-number">1.16.</span> <span class="toc-text">14. 请使用递归算法计算n！</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-%E9%80%92%E5%BD%92%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.17.</span> <span class="toc-text">15. 递归的定义和优缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-%E6%95%B0%E7%BB%84%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">1.18.</span> <span class="toc-text">16. 数组的特征</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-%E8%AF%B7%E5%86%99%E5%87%BA%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%BB%A3%E7%A0%81"><span class="toc-number">1.19.</span> <span class="toc-text">17. 请写出冒泡排序代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-%E8%AF%B7%E5%86%99%E5%87%BA%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">1.20.</span> <span class="toc-text">18. 请写出选择排序的代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#19-%E8%AF%B7%E5%86%99%E5%87%BA%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E4%BB%A3%E7%A0%81"><span class="toc-number">1.21.</span> <span class="toc-text">19. 请写出插入排序的代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#20-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E7%89%B9%E7%82%B9"><span class="toc-number">1.22.</span> <span class="toc-text">20. 可变参数的作用和特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#21-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.23.</span> <span class="toc-text">21. 类和对象的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.24.</span> <span class="toc-text">22. 面向过程和面向对象的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23-this%E5%92%8Csuper%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.25.</span> <span class="toc-text">23. this和super关键字的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24-static%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.26.</span> <span class="toc-text">24. static关键字的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E4%BB%BD%E6%95%B0%E4%B8%8D%E5%90%8C"><span class="toc-number">1.26.1.</span> <span class="toc-text">1. 在内存中份数不同</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%AD%98%E6%94%BE%E7%9A%84%E4%BD%8D%E7%BD%AE%E4%B8%8D%E5%90%8C"><span class="toc-number">1.26.2.</span> <span class="toc-text">2.在内存中存放的位置不同</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%AE%BF%E9%97%AE%E7%9A%84%E6%96%B9%E5%BC%8F%E4%B8%8D%E5%90%8C"><span class="toc-number">1.26.3.</span> <span class="toc-text">3. 访问的方式不同</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E5%88%86%E9%85%8D%E7%A9%BA%E9%97%B4%E7%9A%84%E6%97%B6%E9%97%B4%E4%B8%8D%E5%90%8C"><span class="toc-number">1.26.4.</span> <span class="toc-text">4. 在内存中分配空间的时间不同</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25-final%E5%92%8Cabstract%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.27.</span> <span class="toc-text">25. final和abstract关键字的作用</span></a></li></ol></li></ol></div></div></div><header class="post-bg" id="page-header" style="background-image: url(nullhttps://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">涂祎豪の博客</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 時間軸</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 標籤</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分類</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fas fa-list"></i><span> 清單</span><i class="fas fa-chevron-down expand"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音樂</span></a></li><li><a class="site-page" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 電影</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Java面试整理(基础语法169道)</div></div><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-11-08T02:05:46.661Z" title="发表于 2020-11-08 10:05:46">2020-11-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2020-09-13T03:31:08.000Z" title="更新于 2020-09-13 11:31:08">2020-09-13</time></span></div><div class="meta-secondline"> <span class="post-meta-separator">|</span><span class="post-meta-pv-cv"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><h3 id="Java面试整理-基础语法169道-——陆续更新"><a href="#Java面试整理-基础语法169道-——陆续更新" class="headerlink" title="Java面试整理(基础语法169道) ——陆续更新"></a>Java面试整理(基础语法169道) ——陆续更新</h3><blockquote>
<p>作者：涂祎豪</p>
</blockquote>
<h4 id="1-Java跨平台远离（字节码文件、虚拟机）"><a href="#1-Java跨平台远离（字节码文件、虚拟机）" class="headerlink" title="1.Java跨平台远离（字节码文件、虚拟机）"></a>1.Java跨平台远离（字节码文件、虚拟机）</h4><p>C/C++语言都是直接编译成针对特定平台机器码。如果要跨平台，需要使用相应的编译器重新编译。<br>Java源程序（.java）要先编译成与平台无关的字节码文件（.class），然后字节码文件再<br>解释成机器码运行。解释是通过Java虚拟机来执行的。<br>字节码文件不面相任何具体平台，只面相虚拟机。<br>Java虚拟机是可运行Java字节码文件的虚拟计算机。不同平台的虚拟机是不同的，但它们都提供了相同的接口。<br>Java语言具有一次编译，到处运行的特点。就是说编译后的.class可以跨平台运行，前提是该平台具有相应的Java虚拟机。但是性能比C/C++要低。<br>Java的跨平台远离决定了其性能没有C/C++高。</p>
<h4 id="Java跨平台编译原理"><a href="#Java跨平台编译原理" class="headerlink" title="Java跨平台编译原理"></a>Java跨平台编译原理</h4><p><img src= "/img/loading.gif" data-lazy-src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/20200910184606.png" alt="image-20200910184605185"></p>
<ol>
<li>一次编译，到处运行</li>
<li>编译器的作用：将源文件编译成class文件</li>
<li>虚拟机的作用：将字节码文件class文件解释成对应平台机器码并执行</li>
<li>Java可以跨所有的平台吗？只有提供并安装了相应的虚拟机，就可以跨该平台</li>
<li>虚拟机和解释器的关系：解释器是虚拟机的一个重要组成部分</li>
<li>Java语言的执行要经过编译和解释两个阶段</li>
</ol>
<hr>
<h4 id="C语言跨平台原理"><a href="#C语言跨平台原理" class="headerlink" title="C语言跨平台原理"></a>C语言跨平台原理</h4><p><img src= "/img/loading.gif" data-lazy-src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/20200910191530.png" alt="image-20200910191528618"></p>
<ol>
<li>多次编译，到处运行</li>
<li>C和Java那个平台速度快？ C语言是直接执行代码，Java是先将class文件爱你解释成机器码再执行</li>
<li>两种平台原理那种好？ 互联网上，平台各异，Java的一个编译结果可以放到所有平台上，这个是巨大优势</li>
</ol>
<hr>
<h4 id="2、Java的安全性"><a href="#2、Java的安全性" class="headerlink" title="2、Java的安全性"></a>2、Java的安全性</h4><h5 id="语言层次的安全性主要体现在："><a href="#语言层次的安全性主要体现在：" class="headerlink" title="语言层次的安全性主要体现在："></a>语言层次的安全性主要体现在：</h5><p>Java取消了强大又危险的指针，而代之以引用。由于指针可以进行移动运算，指针可以随便指向一个内存区域，而不管这个区域是否可用，这样做是十分危险的，因为原来之隔内存地址可能存储着和从要数据或者是其他程序所占用的，并且使用指针也容易数组越界。</p>
<h5 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h5><p>不需要程序员直接控制内存回收，由垃圾回收器在后台自动回收不再使用的内存。避免程序错误回收程序核心类库的内存，导致系统崩溃。</p>
<h5 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h5><p>Java异常机制主要依赖于try、catch、finally、throw、throws五个关键字。</p>
<h5 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h5><p>只有在满足强制类型转换规则的情况才能强转成功。</p>
<h5 id="底层的安全性可以从下面来说明："><a href="#底层的安全性可以从下面来说明：" class="headerlink" title="底层的安全性可以从下面来说明："></a>底层的安全性可以从下面来说明：</h5><p>Java在字节码的传输过程中使用了公开密钥加密机制（PKC）</p>
<h5 id="在运行环境提供了四级安全保障机制："><a href="#在运行环境提供了四级安全保障机制：" class="headerlink" title="在运行环境提供了四级安全保障机制："></a>在运行环境提供了四级安全保障机制：</h5><p>字节码校验器 - 类装载器 - 运行是内存布局 - 文件访问限制</p>
<hr>
<h4 id="3、Java三大版本"><a href="#3、Java三大版本" class="headerlink" title="3、Java三大版本"></a>3、Java三大版本</h4><p><strong>Java2平台包括标准版（J2SE）、企业版（J2EE）和微缩版（J2ME）三个版本：</strong><br>Standard Edition（标准版）J2SE包含那些构成Java语言核心的类。</p>
<p><em>比如：数据库连接、接口定义、输入/输出、网络编程</em></p>
<p>Enterprise Edition(企业版) J2EE 包含J2SE 中的类，并且还包含用于开发企业级应用的类。</p>
<p><em>比如servlet、JSP、XML、事务控制</em></p>
<p>Micro Edition(微缩版) J2ME 包含J2SE中一部分类，用于消费类电子产品的软件开发。</p>
<p><em>比如：呼机、智能卡、手机、PDA、机顶盒</em></p>
<p><strong>他们范围是：</strong></p>
<p>J2SE包含于J2EE中，J2ME包含了J2SE的核心类，但新添加了一些专有类应用场合，API的覆盖范围各不相同。</p>
<hr>
<h4 id="4、什么是JVM？什么是JDK？-什么是JRE？"><a href="#4、什么是JVM？什么是JDK？-什么是JRE？" class="headerlink" title="4、什么是JVM？什么是JDK？ 什么是JRE？"></a>4、什么是JVM？什么是JDK？ 什么是JRE？</h4><p><strong>JVM：</strong></p>
<p>​    VM是Java Virtual Machine（Java虚拟机）的缩写，它是整个Java实现跨平台的最核心的部分，所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行，也就是说class并不直接与机器的操作系统相对应，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。JVM是Java平台的基础，和实际的机器一样，它也有自己的指令集，并且在运行时操作不同的内存区域。 JVM通过抽象操作系统和CPU结构，提供了一种与平台无关的代码执行方法，即与特殊的实现方法、主机硬件、主机操作系统无关。JVM的主要工作是解释自己的指令集（即字节码）到CPU的指令集或对应的系统调用，保护用户免被恶意程序骚扰。 JVM对上层的Java源文件是不关心的，它关注的只是由源文件生成的类文件（.class文件）。</p>
<p><strong>JRE :</strong></p>
<p>​    JRE是java runtime environment（java运行环境）的缩写。光有JVM还不能让class文件执行，因为在解释class的时候JVM需要调用解释所需要的类库lib。在JDK的安装目录里你可以找到jre目录，里面有两个文件夹bin和lib,在这里可以认为bin里的就是jvm，lib中则是jvm工作所需要的类库，而jvm和lib和起来就称为jre。所以，在你写完java程序编译成.class之后，你可以把这个.class文件和jre一起打包发给朋友，这样你的朋友就可以运行你写程序了（jre里有运行.class的java.exe）。JRE是Sun公司发布的一个更大的系统，它里面就有一个JVM。JRE就与具体的CPU结构和操作系统有关，是运行Java程序必不可少的（除非用其他一些编译环境编译成.exe可执行文件……），JRE的地位就象一台PC机一样，我们写好的Win32应用程序需要操作系统帮我们运行，同样的，我们编写的Java程序也必须要JRE才能运行。</p>
<p><strong>JDK：</strong></p>
<p>​    JDK是java development kit（java开发工具包）的缩写。每个学java的人都会先在机器上装一个JDK，那 让我们看一下JDK的安装目录。在目录下面有六个文件夹、一个src类库源码压缩包、和其他几个声明文件。其中，真正在运行java时起作用的是以下四个文件夹：bin、include、lib、jre。现在我们可以看出这样一个关系，JDK包含JRE，而JRE包含JVM。</p>
<p><strong>bin：</strong>最主要的是编译器（javac.exe）</p>
<p><strong>include：</strong>java和JVM交互作用的头文件</p>
<p><strong>lib：</strong>类库</p>
<p><strong>jre：</strong>java运行环境</p>
<p>（注意：这里的bin、lib文件夹和jre里的bin、lib是不同的）</p>
<p>​    总的来说JDK是用于java程序的开发,而jre则是只能运行class而没有编译的功能。eclipse、idea等其他IDE有自己的编译器而不是用JDK bin目录中自带的，所以在安装时你会发现他们只要求你选jre路径就ok了。</p>
<p><strong>JDK,JRE,JVM三者关系概括如下：</strong></p>
<p>​    jdk是JAVA程序开发时用的开发工具包，其内部也有JRE运行环境JRE。JRE是JAVA程序运行时需要的运行环境，就是说如果你光是运行JAVA程序而不是去搞开发的话，只安装JRE就能运行已经存在的JAVA程序了。JDk、JRE内部都包含JAVA虚拟机JVM，JAVA虚拟机内部包含许多应用程序的类的解释器和类加载器等等。</p>
<hr>
<h4 id="Java三种注释类型"><a href="#Java三种注释类型" class="headerlink" title="Java三种注释类型"></a>Java三种注释类型</h4><p>共有单行注释、多行注释、文档注释3种注释类型。</p>
<h5 id="单行注释，采用“-”方式-只能注释一行代码。如："><a href="#单行注释，采用“-”方式-只能注释一行代码。如：" class="headerlink" title="单行注释，采用“//”方式.只能注释一行代码。如："></a>单行注释，采用“//”方式.只能注释一行代码。如：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//成员变量</span></span><br></pre></td></tr></table></figure>

<h5 id="多行注释，采用“-…-”方式，可注释多行代码，其中不允许出现嵌套。如："><a href="#多行注释，采用“-…-”方式，可注释多行代码，其中不允许出现嵌套。如：" class="headerlink" title="多行注释，采用“/…/”方式，可注释多行代码，其中不允许出现嵌套。如："></a>多行注释，采用“/<em>…</em>/”方式，可注释多行代码，其中不允许出现嵌套。如：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">System.out.println(&quot;a&quot;);</span></span><br><span class="line"><span class="comment">System.out.println(&quot;b&quot;);</span></span><br><span class="line"><span class="comment">System.out.println(&quot;c&quot;);</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h5 id="文档注释，采用“-…-”方式，如："><a href="#文档注释，采用“-…-”方式，如：" class="headerlink" title="文档注释，采用“/*…/”方式，如："></a>文档注释，采用“/*<em>…</em>/”方式，如：</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> 涂祎豪</span></span><br><span class="line"><span class="comment">* <span class="doctag">@descripted</span> QQ:2914021718</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="6-八种基本数据类型及其字节数"><a href="#6-八种基本数据类型及其字节数" class="headerlink" title="6. 八种基本数据类型及其字节数"></a>6. 八种基本数据类型及其字节数</h4><p><img src= "/img/loading.gif" data-lazy-src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/20200910165100.png" alt="image-20200910165058627"></p>
<hr>
<h4 id="7-i-和-i的异同之处"><a href="#7-i-和-i的异同之处" class="headerlink" title="7. i++和++i的异同之处"></a>7. i++和++i的异同之处</h4><h5 id="共同点："><a href="#共同点：" class="headerlink" title="共同点："></a>共同点：</h5><ol>
<li>i++和++i都是变量自增1，都等价于i=i+1</li>
<li>如果i++,++i是一条单独的语句，两者没有任何区别</li>
<li>i++和++i的使用仅仅针对变量。 5++和++5会报错，因为5不是变量。</li>
</ol>
<h5 id="不同点："><a href="#不同点：" class="headerlink" title="不同点："></a>不同点：</h5><p>如果i++,++i不是一条单独的语句，他们就有区别</p>
<p>i++ ：先运算后增1。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> y=x++;System.out.println(<span class="string">&quot;x=&quot;</span>+x+<span class="string">&quot;, y=&quot;</span>+y);<span class="comment">//以上代码运行后输出结果为：x=6, y=5</span></span><br></pre></td></tr></table></figure>

<p>++i ： 先增1后运算。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> y=++x;</span><br><span class="line">System.out.println(<span class="string">&quot;x=&quot;</span>+x+<span class="string">&quot;, y=&quot;</span>+y);<span class="comment">//以上代码运行后输出结果为：x=6, y=6</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="8-amp-和-amp-amp-和-的区别和联系"><a href="#8-amp-和-amp-amp-和-的区别和联系" class="headerlink" title="8. &amp;和&amp;&amp; , |和|| 的区别和联系"></a>8. &amp;和&amp;&amp; , |和|| 的区别和联系</h4><p><strong>&amp;和&amp;&amp;的联系(共同点)：</strong></p>
<p>&amp;和&amp;&amp;都可以用作逻辑与运算符，但是要看使用时的具体条件来决定。</p>
<p><strong>操作数1&amp;操作数2，操作数1&amp;&amp;操作数2，</strong></p>
<p><strong>表达式1&amp;表达式2，表达式1&amp;&amp;表达式2，</strong></p>
<p><strong>情况1：</strong>当上述的操作数是boolean类型变量时，&amp;和&amp;&amp;都可以用作逻辑与运算符。</p>
<p><strong>情况2：</strong>当上述的表达式结果是boolean类型变量时，&amp;和&amp;&amp;都可以用作逻辑与运算符。表示逻辑与(and)，当运算符两边的表达式的结果或操作数都为true时，整个运算结果才为true，否则，只要有一方为false，结果都为false。</p>
<p><strong>&amp;和&amp;&amp;的区别：</strong></p>
<ol>
<li><p>&amp; 称为逻辑与运算符，&amp;&amp; 称为短路与运算符，也可叫逻辑与运算符。</p>
<p> 对于&amp;：无论任何情况，&amp;两边的操作数或表达式都会参与计算。</p>
<p> 对于&amp;&amp;：当&amp;&amp;左边的操作数为false或左边表达式结果为false时，&amp;&amp;右边的操作数或表达式将不参与计算，此时最终结果都为false。</p>
<p> 综上所述，如果逻辑与运算的第一个操作数是false或第一个表达式的结果为false时，对于第二个操作数或表达式是否进行运算，对最终的结果没有影响，结果肯定是false。推介平时多使用&amp;&amp;，因为它效率更高些。</p>
</li>
<li><p>&amp;还可以用作位运算符。当&amp;两边操作数或两边表达式的结果不是boolean类型时，&amp;用于按位与运算符的操作。</p>
<p>|和||的区别和联系与&amp;和&amp;&amp;的区别和联系类似</p>
</li>
</ol>
<hr>
<h4 id="9-用最有效率的方法算出2乘以8等于多少"><a href="#9-用最有效率的方法算出2乘以8等于多少" class="headerlink" title="9. 用最有效率的方法算出2乘以8等于多少"></a>9. 用最有效率的方法算出2乘以8等于多少</h4><p>使用位运算来实现效率最高。位运算符是对操作数以二进制比特位为单位进行操作和运算，操作数和结果都是整型数。</p>
<p>对于位运算符“&lt;&lt;”, 是将一个数左移n位，就相当于乘以了2的n次方，那么，一个数乘以8只要将其左移3位即可，位运算cpu直接支持的，效率最高。所以，2乘以8等于几的最效率的方法是2 &lt;&lt; 3。</p>
<hr>
<h4 id="10-基本数据类型的类型转换规则"><a href="#10-基本数据类型的类型转换规则" class="headerlink" title="10. 基本数据类型的类型转换规则"></a>10. 基本数据类型的类型转换规则</h4><p>基本类型转换分为自动转换和强制转换。</p>
<p><strong>自动转换规则：</strong></p>
<p>容量小的数据类型 可以自动转换成容量大的数据类型，也可以说低级自动向高级转换。这儿的容量指的不是字节数，而是指类型表述的范围。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/20200910191721.png" alt="image-20200910191719252"></p>
<p><strong>强制转换规则：</strong></p>
<p>高级变为低级需要强制转换。</p>
<p><strong>如何转换：</strong></p>
<ol>
<li>赋值运算符“=”右边的转换，先自动转换成表达式中级别最高的数据类型，再进行运算。</li>
<li>赋值运算符 “=” 两侧的转换，若左边级别&gt;右边级别，会自动转换；若左边级别 == 右边级别，不用转换；若左边级别 &lt; 右边级别，需强制转换。</li>
<li>可以将整型常量直接赋值给byte, short, char等类型变量，而不需要进行强制类型转换，前提是不超出其表述范围，否则必须进行强制转换。</li>
</ol>
<hr>
<h4 id="11-if和switch的异同之处"><a href="#11-if和switch的异同之处" class="headerlink" title="11. if和switch的异同之处"></a>11. if和switch的异同之处</h4><p><strong>相同之处</strong>：</p>
<p>都是分支语句，多超过一种的情况进行判断处理。</p>
<p><strong>不同之处：</strong></p>
<p>switch更适合用于多分支情况，就是有很多种情况需要判断处理，判断条件类型单一，只有一个入口，在分支执行完后（如果没有break跳出），不加判断地执行下去; 而if—elseif—else多分枝主要适用于分支较少的分支结构，判断类型不是单一，只要一个分支被执行后，后边的分支不再执行。</p>
<p>switch为等值判断（不允许比如&gt;= &lt;=），而if为等值和区间都可以，if的使用范围大。</p>
<hr>
<h4 id="12-while和do-while循环的区别"><a href="#12-while和do-while循环的区别" class="headerlink" title="12. while和do-while循环的区别"></a>12. while和do-while循环的区别</h4><p>while先判断后执行，第一次判断为false , 循环体一次都不执行。<br>do while先执行 后判断，最少执行1次。<br>如果while循环第一次判断为true, 则两种循环没有区别。</p>
<hr>
<h4 id="13-break和continue的作用"><a href="#13-break和continue的作用" class="headerlink" title="13. break和continue的作用"></a>13. break和continue的作用</h4><p><strong>break:</strong> 结束当前循环并退出当前循环体。break还可以退出switch语句<br><strong>continue:</strong> 循环体中后续的语句不执行，但是循环没有结束，继续进行循环条件的判断（for循环还会i++）。continue只是结束本次循环。</p>
<hr>
<h4 id="14-请使用递归算法计算n！"><a href="#14-请使用递归算法计算n！" class="headerlink" title="14. 请使用递归算法计算n！"></a>14. 请使用递归算法计算n！</h4><p>一个正整数的阶乘（factorial）是所有小于及等于该数的正整数的积，并且0的阶乘为1。 自然数n的阶乘写作n!。1808年，基斯顿·卡曼引进这个表示法。 亦即n!=1×2×3×…×n。阶乘亦可以递归方式定义：0!=1，n!=(n-1)!×n。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* n阶乘</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recursion</span> </span>&#123;</span><br><span class="line">	<span class="comment">//阶乘算法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (num==<span class="number">0</span> || num== <span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> num*factorial(num-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Recursion recursion = <span class="keyword">new</span> Recursion();</span><br><span class="line">	<span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> factorial = recursion.factorial(n);</span><br><span class="line">	System.out.println(factorial);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="15-递归的定义和优缺点"><a href="#15-递归的定义和优缺点" class="headerlink" title="15. 递归的定义和优缺点"></a>15. 递归的定义和优缺点</h4><p>​    递归算法是一种直接或者间接地调用自身算法的过程。在计算机编写程序中，递归算法对解决一大类问题是十分有效的，它往往使算法的描述简洁而且易于理解。</p>
<p><strong>递归算法解决问题的特点：</strong></p>
<ol>
<li>递归就是在过程或函数里调用自身。</li>
<li>在使用递归策略时，必须有一个明确的递归结束条件，称为递归出口。</li>
<li>递归算法解题通常显得很简洁，但运行效率较低。所以一般不提倡用递归算法设计程序。</li>
<li>在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成栈溢出等。所以一般不提倡用递归算法设计程序。</li>
</ol>
<hr>
<h4 id="16-数组的特征"><a href="#16-数组的特征" class="headerlink" title="16. 数组的特征"></a>16. 数组的特征</h4><p>数组是（相同类型数据）的（有序）（集合）</p>
<p>数组会在内存中开辟一块连续的空间，每个空间相当于之前的一个变量，称为数组的元素element元素的表示 数组名[下标或者索引] <code>scores[7] scores[0] scores[9]</code></p>
<p>索引从0开始</p>
<p>每个数组元素有默认值<code>double 0.0; boolean false; int 0</code></p>
<p>数组元素有序的，不是大小顺序，是索引的顺序</p>
<p>数组中可以存储基本数据类型，可以存储引用数据类型；但是对于一个数组而言，数组的类型是固定的，只能是一个length:数组的长度</p>
<p>数组的长度是固定的，一经定义，不能再发生变化（数组的扩容）</p>
<hr>
<h4 id="17-请写出冒泡排序代码"><a href="#17-请写出冒泡排序代码" class="headerlink" title="17. 请写出冒泡排序代码"></a>17. 请写出冒泡排序代码</h4><p>冒泡排序（Bubble Sort），是一种计算机科学领域的较简单的排序算法。</p>
<p>它重复地走访过要排序的元素列，依次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从A到Z）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说该元素列已经排序完成。</p>
<p>这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端（升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。</p>
<p>冒泡排序算法的原理如下：</p>
<ol>
<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>
<li>对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 冒泡排序</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bubble</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">		<span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">// 外层循环，它决定一共走几趟 //-1为了防止溢出</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> flag = <span class="number">0</span>; <span class="comment">//通过符号位可以减少无谓的比较，如果已经有序了，就退出循环</span></span><br><span class="line">			<span class="comment">//内层循环，它决定每趟走一次</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j++) &#123;</span><br><span class="line">			<span class="comment">//如果后一个大于前一个,则换位</span></span><br><span class="line">			<span class="keyword">if</span> (array[j + <span class="number">1</span>] &gt; array[j]) &#123;</span><br><span class="line">			temp = array[j];</span><br><span class="line">			array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">			array[j + <span class="number">1</span>] = temp;</span><br><span class="line">			flag = <span class="number">1</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">			<span class="keyword">if</span>(flag == <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> array;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Bubble bubble = <span class="keyword">new</span> Bubble();</span><br><span class="line">    	<span class="keyword">int</span>[] array = &#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>&#125;;</span><br><span class="line">		<span class="keyword">int</span>[] sort = bubble.sort(array);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> num:sort)&#123;</span><br><span class="line">			System.out.print(num+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="18-请写出选择排序的代码"><a href="#18-请写出选择排序的代码" class="headerlink" title="18. 请写出选择排序的代码"></a>18. 请写出选择排序的代码</h4><p>选择排序（Selection sort）是一种简单直观的排序算法。它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到全部待排序的数据元素排完。 选择排序是不稳定的排序方法。</p>
<table>
<thead>
<tr>
<th>排序方法</th>
<th>最好时间</th>
<th>平均时间</th>
<th>最坏时间</th>
<th>辅助空间</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>直接插入</td>
<td>O(n)</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>二分插入</td>
<td>O(n)</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>希  尔</td>
<td></td>
<td>O(n^1.25)</td>
<td></td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>冒  泡</td>
<td>O(n)</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>稳定</td>
</tr>
<tr>
<td>快  速</td>
<td>O(nlgn)</td>
<td>O(nlgn)</td>
<td>O(n^2)</td>
<td>O(lgn)</td>
<td>不稳定</td>
</tr>
<tr>
<td>直接选择</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆</td>
<td>O(nlgn)</td>
<td>O(nlgn)</td>
<td>O(nlgn)</td>
<td></td>
<td>不稳定</td>
</tr>
<tr>
<td>归  并</td>
<td>O(nlgn)</td>
<td>O(nlgn)</td>
<td>O(nlgn)</td>
<td>O(n)</td>
<td>稳定</td>
</tr>
<tr>
<td>基   数</td>
<td>O(d(rd+n))</td>
<td>O(d(rd+n))</td>
<td>O(d(rd+n))</td>
<td>O(rd+n)</td>
<td>稳定</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 选择排序</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelectSort</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span> arr[]) &#123;</span><br><span class="line">		<span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">			<span class="comment">// 认为目前的数就是最小的, 记录最小数的下标</span></span><br><span class="line">			<span class="keyword">int</span> minIndex = i;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class="line">				<span class="comment">// 修改最小值的下标</span></span><br><span class="line">				minIndex = j;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">				<span class="comment">// 当退出for就找到这次的最小值,就需要交换位置了</span></span><br><span class="line">			<span class="keyword">if</span> (i != minIndex) &#123;</span><br><span class="line">   				 <span class="comment">//交换当前值和找到的最小值的位置</span></span><br><span class="line">				temp = arr[i];</span><br><span class="line">				arr[i] = arr[minIndex];</span><br><span class="line">				arr[minIndex] = temp;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">			<span class="keyword">return</span> arr;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		SelectSort selectSort = <span class="keyword">new</span> SelectSort();</span><br><span class="line">		<span class="keyword">int</span>[] array = &#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>&#125;;</span><br><span class="line">		<span class="keyword">int</span>[] sort = selectSort.sort(array);</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> num:sort)&#123;</span><br><span class="line">			System.out.print(num+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="19-请写出插入排序的代码"><a href="#19-请写出插入排序的代码" class="headerlink" title="19. 请写出插入排序的代码"></a>19. 请写出插入排序的代码</h4><p>​    有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序方法——插入排序法</p>
<p>​    插入排序的基本操作就是将一个数据插入到已经排好序的有序数据中，从而得到一个新的、个数加一的有序数据，算法适用于少量数据的排序，时间复杂度为O(n^2)。是稳定的排序方法。插入算法把要排序的数组分成两部分：第一部分包含了这个数组的所有元素，但将最后一个元素除外（让数组多一个空间才有插入的位置），而第二部分就只包含这一个元素（即待插入元素）。在第一部分排序完成后，再将这个最后元素插入到已排好序的第一部分中。</p>
<p>​    插入排序的基本思想是：每步将一个待排序的记录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。</p>
<p>​    包括：直接插入排序，二分插入排序（又称折半插入排序），链表插入排序，希尔排序（又称缩小增量排序）。属于稳定排序的一种（通俗地讲，就是两个相等的数不会交换位置） 。</p>
<p>​    一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下： ⒈ 从第一个元素开始，该元素可以认为已经被排序 ⒉ 取出下一个元素，在已经排序的元素序列中从后向前扫描 ⒊ 如果该元素（已排序）大于新元素，将该元素移到下一位置 ⒋ 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 ⒌ 将新元素插入到下一位置中 ⒍重复步骤2~5</p>
<p>​    如果比较操作的代价比交换操作大的话，可以采用二分查找法来减少比较操作的数目。该算法可以认为是插入排序的一个变种，称为二分查找排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 插入排序</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InsertSort</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[]arr)&#123;</span><br><span class="line">		<span class="comment">//如果传入的数组为空或者只有一个值,就直接返回</span></span><br><span class="line">    	<span class="keyword">if</span>(arr == <span class="keyword">null</span> || arr.length &lt; <span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> arr;</span><br><span class="line">	&#125;</span><br><span class="line">		<span class="comment">//不为空则进循环判断</span></span><br><span class="line">		<span class="comment">//外层循环控制总数量</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">		<span class="comment">//内层循环依次减少并提出结果</span></span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&gt;<span class="number">0</span>;j--)&#123;</span><br><span class="line">		<span class="comment">//如果当前数字小于前一个,则交换,否则不变</span></span><br><span class="line">			<span class="keyword">if</span>(arr[j]&lt;arr[j-<span class="number">1</span>])&#123;</span><br><span class="line">				<span class="keyword">int</span> temp=arr[j];</span><br><span class="line">				arr[j]=arr[j-<span class="number">1</span>];</span><br><span class="line">				arr[j-<span class="number">1</span>]=temp;</span><br><span class="line">			&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	InsertSort insertSort = <span class="keyword">new</span> InsertSort();</span><br><span class="line">	<span class="keyword">int</span>[] array = &#123;<span class="number">2</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span>[] sort = insertSort.sort(array);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> num:sort)&#123;</span><br><span class="line">		System.out.print(num+<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="20-可变参数的作用和特点"><a href="#20-可变参数的作用和特点" class="headerlink" title="20. 可变参数的作用和特点"></a>20. 可变参数的作用和特点</h4><p>详解 : <a target="_blank" rel="noopener" href="https://www.cnblogs.com/uptownBoy/articles/1698335.html">https://www.cnblogs.com/uptownBoy/articles/1698335.html</a></p>
<p><strong>总结1：</strong>可变参数</p>
<ol>
<li>可变参数的形式 …</li>
<li>可变参数只能是方法的形参</li>
<li>可变参数对应的实参可以0,1,2…..n个，也可以是一个数组</li>
<li>在可变参数的方法中，将可变参数当做数组来处理</li>
<li>可变参数最多有一个，只能是最后一个</li>
<li>可变参数好处：方便 简单 减少重载方法的数量</li>
<li>如果定义了可变参数的方法，不允许同时定义相同类型数组参数的方法</li>
</ol>
<p><strong>总结2：</strong> 数组做形参和可变参数做形参联系和区别</p>
<p><strong>联系：</strong></p>
<ol>
<li>实参都可以是数组；</li>
<li>方法体中，可变参数本质就是当做数组来处理</li>
</ol>
<p><strong>区别：</strong></p>
<ol>
<li>个数不同 可变参数只能有一个数组参数可以多个</li>
<li>位置不同 可变参数只能是最后一个 数组参数位置任意</li>
<li>实参不同 可变参数实参可以0,1,2…..个，也可以是一个数组，数组的实参只能是数组</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span>... values)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line">sum += values[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<h4 id="21-类和对象的关系"><a href="#21-类和对象的关系" class="headerlink" title="21. 类和对象的关系"></a>21. 类和对象的关系</h4><p>​    类是对象的抽象，而对象是类的具体实例。 类是抽象的，不占用内存，而对象是具体的，占用存储空间。 类是用于创建对象的蓝图，类就是一个带方法和变量的特定类型</p>
<p>​    类和对象好比图纸和实物的关系，模具和铸件的关系。</p>
<p>​    比如人类就是一个概念，人类具有身高，体重等属性。人类可以做吃饭、说话等方法。</p>
<p>​    小明就是一个具体的人，也就是实例，他的属性是具体的身高200cm，体重180kg，他做的方法是具体的吃了一碗白米饭，说了“12345”这样一句话。</p>
<p>​    还可以有小红,小蓝等具体的人即对象,但他们都是人类的实例,即类。</p>
<hr>
<h4 id="22-面向过程和面向对象的区别"><a href="#22-面向过程和面向对象的区别" class="headerlink" title="22. 面向过程和面向对象的区别"></a>22. 面向过程和面向对象的区别</h4><p>​    两者都是软件开发思想，先有面向过程，后有面向对象。在大型项目中，针对面向过程的不足推出了面向对象开发思想。</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/20200910205016.png" alt="image-20200910205012487"></p>
<p><strong>区别:</strong></p>
<p><strong>编程思路不同：</strong> 面向过程以实现功能的函数开发为主，而面向对象要首先抽象出类、属性及其方法，然后通过实例化类、执行方法来完成功能。</p>
<p><strong>封装性：</strong>都具有封装性，但是面向过程是封装的是功能，而面向对象封装的是数据和功能。</p>
<p>面向对象具有继承性和多态性，而面向过程没有继承性和多态性，所以面向对象优势是明显。</p>
<p><strong>方法重载和方法重写（覆盖）的区别：</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>英文</th>
<th>位置不同</th>
<th>作用不同</th>
</tr>
</thead>
<tbody><tr>
<td>重载</td>
<td>overlord</td>
<td>同一个类中</td>
<td>在一个类里面为一种行为提供过重实现方式并提高可读性</td>
</tr>
<tr>
<td>重写</td>
<td>override</td>
<td>子类和父类间</td>
<td>父类方法无法满足子类的要求，子类通过方法重写满足要求</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th></th>
<th>修饰符</th>
<th>返回值</th>
<th>方法名</th>
<th>参数</th>
<th>抛出异常</th>
</tr>
</thead>
<tbody><tr>
<td>重载</td>
<td>无关</td>
<td>无关</td>
<td>相同</td>
<td>不同</td>
<td>无关</td>
</tr>
<tr>
<td>重写</td>
<td>大于等于</td>
<td>小于等于</td>
<td>相同</td>
<td>相同</td>
<td>小于等于</td>
</tr>
</tbody></table>
<hr>
<h4 id="23-this和super关键字的作用"><a href="#23-this和super关键字的作用" class="headerlink" title="23. this和super关键字的作用"></a>23. this和super关键字的作用</h4><p>​    this是对象内部指代自身的引用,同时也是解决成员变量和局部变量同名问题；this可以调用成员变量，不能调用局部变量；this也可以调用成员方法，但是在普通方法中可以省略this，在构造方法中不允许省略，必须是构造方法的第一条语句。而且在静态方法当中不允许出现this关键字。</p>
<p>​    super代表对当前对象的直接父类对象的引用，super可以调用直接父类的成员变量（注意权限修饰符的影响，不如不能访问private成员）</p>
<p>​    super可以调用直接父类的成员方法（注意权限修饰符的影响，比如不能访问private成员）；super可以调用直接父类的构造方法，只限构造方法中使用，且必须是第一条语句。</p>
<hr>
<h4 id="24-static关键字的作用"><a href="#24-static关键字的作用" class="headerlink" title="24. static关键字的作用"></a>24. static关键字的作用</h4><p>​    static可以修饰变量、方法、代码块和内部类</p>
<p>​    static属性属于这个类所有，即由该类创建的所有对象共享同一个static属性。可以对象创建后通过对象名.属性名和类名.属性名两种方式来访问。也可以在没有创建任何对象之前通过类名.属性名的方式来访问。</p>
<p>​    .static变量和非static变量的区别(都是成员变量，不是局部变量)</p>
<h5 id="1-在内存中份数不同"><a href="#1-在内存中份数不同" class="headerlink" title="1. 在内存中份数不同"></a>1. 在内存中份数不同</h5><p>不管有多少个对象，static变量只有1份。对于每个对象，实例变量都会有单独的一份</p>
<p>static变量是属于整个类，也称为类变量。而非静态变量是属于对象的，也称为实例变量</p>
<h5 id="2-在内存中存放的位置不同"><a href="#2-在内存中存放的位置不同" class="headerlink" title="2.在内存中存放的位置不同"></a>2.在内存中存放的位置不同</h5><p>静态变量存在方法区中， 实例变量存在堆内存中</p>
<p><img src= "/img/loading.gif" data-lazy-src="https://malloc-img.oss-cn-hangzhou.aliyuncs.com/img/20200912211707.png" alt="image-20200912211705895"></p>
<h5 id="3-访问的方式不同"><a href="#3-访问的方式不同" class="headerlink" title="3. 访问的方式不同"></a>3. 访问的方式不同</h5><p><strong>实例变量：</strong>对象名.变量名 <em>stu1.name=”小明明”</em></p>
<p><strong>静态变量：</strong>对象名.变量名 <em>stu1.schoolName=”西二旗小学”;</em> 不推荐如此使用</p>
<p>*类名.变量名 Student.schoolName=”东三旗小学”;*推荐使用</p>
<h5 id="4-在内存中分配空间的时间不同"><a href="#4-在内存中分配空间的时间不同" class="headerlink" title="4. 在内存中分配空间的时间不同"></a>4. 在内存中分配空间的时间不同</h5><p><strong>实例变量：</strong>创建对象的时候才分配了空间。静态变量：第一次使用类的时候</p>
<p><em>Student.schoolName=”东三旗小学”;<em>或者</em>Student stu1 = new Student(“小明”,”男”,20,98);</em></p>
<p>static方法也可以通过对象名.方法名和类名.方法名两种方式来访问</p>
<p>static代码块。当类被第一次使用时（可能是调用static属性和方法，或者创建其对象）执行静态代码块，且只被执行一次，主要作用是实现static属性的初始化。</p>
<p><strong>static内部类：</strong>属于整个外部类，而不是属于外部类的每个对象。不能访问外部类的非静态成员（变量或者方法），可以访问外部类的静态成员</p>
<hr>
<h4 id="25-final和abstract关键字的作用"><a href="#25-final和abstract关键字的作用" class="headerlink" title="25. final和abstract关键字的作用"></a>25. final和abstract关键字的作用</h4><p>final和abstract是功能相反的两个关键字，可以对比记忆</p>
<p>abstract可以用来修饰类和方法，不能用来修饰属性和构造方法；使用abstract修饰的类是抽象类，需要被继承，使用abstract修饰的方法是抽象方法，需要子类被重写。</p>
<p>final可以用来修饰类、方法和属性，不能修饰构造方法。使用final修饰的类不能被继承，使用final修饰的方法不能被重写，使用final修饰的变量的值不能被修改，所以就成了常量。</p>
<p>特别注意：final修饰基本类型变量，其值不能改变，由原来的变量变为常量；但是final修饰引用类型变量，栈内存中的引用不能改变，但是所指向的堆内存中的对象的属性值仍旧可以改变。例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">final</span> People people = <span class="keyword">new</span> People(<span class="string">&quot;狂神&quot;</span>);</span><br><span class="line">		dog.name = <span class="string">&quot;malloc&quot;</span>;<span class="comment">//正确</span></span><br><span class="line">		people = <span class="keyword">new</span> People(<span class="string">&quot;malloc&quot;</span>);<span class="comment">//错误</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">涂祎豪</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2020/11/08/Java%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/">http://example.com/2020/11/08/Java%E9%9D%A2%E8%AF%95%E6%95%B4%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">涂祎豪の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/11/08/MongoDB%E5%AD%A6%E4%B9%A0/"><img class="prev-cover" data-lazy-src="nullhttps://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MongoDB学习</div></div></a></div><div class="next-post pull-right"><a href="/2020/11/08/Idea%E6%9B%B4%E6%94%B9jdk%E7%89%88%E6%9C%AC/"><img class="next-cover" data-lazy-src="nullhttps://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Idea更改jdk版本</div></div></a></div></nav></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2020 By 涂祎豪</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div></div></footer></div><section id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" type="button" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" type="button" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><div class="js-pjax"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script>cdn_url = ""</script><script src="/" data-pjax></script></div></body></html>